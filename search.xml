<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Best Time to Buy and Sell Stock III</title>
    <url>/2020/05/16/Best-Time-to-Buy-and-Sell-Stock-III/</url>
    <content><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote><p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete at most two transactions.<br>Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p>
<p>Example 1:<br>Input: [3,3,5,0,0,3,1,4]<br>Output: 6<br>Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3</p>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">leetcode.com/problems/best-time-to-buy-and-sell-stock-iii</a></cite></footer></blockquote>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">brute force的优化</span></span><br><span class="line"><span class="comment">双向dp: 一个从左往右计算max profit, 另一个从右往左计算，最后分割，然后取max</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prices.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = prices.length;</span><br><span class="line">    <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> min = prices[<span class="number">0</span>];</span><br><span class="line">    left[<span class="number">0</span>] = <span class="number">0</span>;        </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;                        </span><br><span class="line">        <span class="keyword">if</span> (prices[i] &gt; prices[i-<span class="number">1</span>]) &#123;</span><br><span class="line">            left[i] = Math.max(prices[i]-min, left[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            left[i] = left[i-<span class="number">1</span>];</span><br><span class="line">            min = Math.min(min, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注意计算从右往左的时候是记录max</span></span><br><span class="line">    <span class="keyword">int</span> max = prices[len-<span class="number">1</span>];</span><br><span class="line">    right[len-<span class="number">1</span>] = <span class="number">0</span>;        </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len-<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;                                    </span><br><span class="line">        <span class="keyword">if</span> (prices[i] &lt; prices[i+<span class="number">1</span>]) &#123;</span><br><span class="line">            right[i] = Math.max(max-prices[i], right[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            right[i] = right[i+<span class="number">1</span>];</span><br><span class="line">            max = Math.max(max, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = Math.max(left[len-<span class="number">1</span>], right[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len-<span class="number">1</span>; i++) &#123;</span><br><span class="line">        res = Math.max(left[i]+right[i+<span class="number">1</span>], res); </span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Stock</tag>
      </tags>
  </entry>
  <entry>
    <title>3Sum</title>
    <url>/2020/05/14/3Sum/</url>
    <content><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote><p>Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.<br>Note:<br>The solution set must not contain duplicate triplets.<br>Example:<br>Given array nums = [-1, 0, 1, 2, -1, -4],<br>A solution set is:<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/3sum/" target="_blank" rel="noopener">leetcode.com/problems/3sum</a></cite></footer></blockquote>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Algorithm: First, get two sum by 0 - nums[index];</span></span><br><span class="line"><span class="comment">then, similarly solve two sum problem;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (nums.length &lt; <span class="number">3</span>) <span class="keyword">return</span> result;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//[-1, 0, 1, 2, -1, -4]</span></span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> target = <span class="number">0</span> - nums[i];        </span><br><span class="line">        <span class="keyword">int</span> left = i + <span class="number">1</span>, right = nums.length - <span class="number">1</span>;            </span><br><span class="line">        CalculateTwoSum(nums, target, left, right, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CalculateTwoSum</span><span class="params">(<span class="keyword">int</span>[] nums,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> target,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> left, </span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> right, </span></span></span><br><span class="line"><span class="function"><span class="params">                            List&lt;List&lt;Integer&gt;&gt; result)</span> </span>&#123;        </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;            </span><br><span class="line">        <span class="keyword">if</span> (nums[left] + nums[right] == target) &#123;</span><br><span class="line">            List&lt;Integer&gt; candidate = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            candidate.add(-target);</span><br><span class="line">            candidate.add(nums[left]);</span><br><span class="line">            candidate.add(nums[right]);                                        </span><br><span class="line">            result.add(candidate);</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left-<span class="number">1</span>]) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right+<span class="number">1</span>]) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[left] + nums[right] &lt; target) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Sum</tag>
      </tags>
  </entry>
  <entry>
    <title>Best Time to Buy and Sell Stock II</title>
    <url>/2020/05/15/Best-Time-to-Buy-and-Sell-Stock-II/</url>
    <content><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote><p>Say you have an array prices for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).<br>Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p>
<p>Example 1:<br>Input: [7,1,5,3,6,4]<br>Output: 7<br>Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4. Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.</p>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">leetcode.com/problems/best-time-to-buy-and-sell-stock-ii</a></cite></footer></blockquote>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">联想一下直方图，求最大的差距</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>])</span><br><span class="line">            maxprofit += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxprofit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Stock</tag>
      </tags>
  </entry>
  <entry>
    <title>1-bit and 2-bit Characters</title>
    <url>/2020/05/16/1-bit-and-2-bit-Characters/</url>
    <content><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote><p>We have two special characters. The first character can be represented by one bit 0. The second character can be represented by two bits (10 or 11).</p>
<p>Now given a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero.</p>
<p>Example 1:<br>Input:<br>bits = [1, 0, 0]<br>Output: True<br>Explanation:<br>The only way to decode it is two-bit character and one-bit character. So the last character is one-bit character.</p>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/1-bit-and-2-bit-characters/" target="_blank" rel="noopener">leetcode.com/problems/1-bit-and-2-bit-characters</a></cite></footer></blockquote>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOneBitCharacter</span><span class="params">(<span class="keyword">int</span>[] bits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> check(<span class="number">0</span>,bits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span>[] bits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= bits.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index == bits.length-<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index == bits.length-<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bits[index] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (bits[index] == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> check(index+<span class="number">2</span>,bits);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> check(index+<span class="number">1</span>,bits);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
  </entry>
  <entry>
    <title>Best Time to Buy and Sell Stock IV</title>
    <url>/2020/05/16/Best-Time-to-Buy-and-Sell-Stock-IV/</url>
    <content><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote><p>Say you have an array for which the i-th element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete at most k transactions.<br>Note:<br>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
<p>Example 1:<br>Input: [2,4,1], k = 2<br>Output: 2<br>Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.</p>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">leetcode.com/problems/best-time-to-buy-and-sell-stock-iv</a></cite></footer></blockquote>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= prices.length / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                profit += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        best[i][j] 表示前i天，至多进行j次交易时的最大获益</span></span><br><span class="line"><span class="comment">        sell[i][j] 表示前i天，至多进行j次交易，并且第i天卖出手中的股票时的最大获益</span></span><br><span class="line"><span class="comment">        状态转移:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        sell[i][j] = max(best[i - 1][j - 1], sell[i - 1][j]) + prices[i] - prices[i - 1]</span></span><br><span class="line"><span class="comment">        best[i][j] = max(best[i - 1][j], sell[i][j])</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="keyword">int</span>[][] sell = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][n + <span class="number">1</span>]; <span class="comment">// sell[i][j] 表示前i天，至多进行j次交易，第i天必须sell的最大获益</span></span><br><span class="line">    <span class="keyword">int</span>[][] best = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][n + <span class="number">1</span>]; <span class="comment">// best[i][j] 表示前i天，至多进行j次交易，第i天可以不sell的最大获益</span></span><br><span class="line"></span><br><span class="line">    sell[<span class="number">0</span>][<span class="number">0</span>] = best[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        sell[<span class="number">0</span>][i] = best[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> gainorlose = prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">        sell[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">            sell[i][j] = Math.max(best[(i - <span class="number">1</span>)][j - <span class="number">1</span>] + gainorlose, sell[(i - <span class="number">1</span>)][j] + gainorlose);</span><br><span class="line">            best[i][j] = Math.max(best[(i - <span class="number">1</span>)][j], sell[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> best[(n - <span class="number">1</span>)][k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Stock</tag>
      </tags>
  </entry>
  <entry>
    <title>Check If a Number Is Majority Element in a Sorted Array</title>
    <url>/2020/05/15/Check-If-a-Number-Is-Majority-Element-in-a-Sorted-Array/</url>
    <content><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote><p>Given an array nums sorted in non-decreasing order, and a number target, return True if and only if target is a majority element.</p>
<p>A majority element is an element that appears more than N/2 times in an array of length N.</p>
<p>Example:<br>Input: nums = [2,4,5,5,5,5,5,6,6], target = 5<br>Output: true</p>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/check-if-a-number-is-majority-element-in-a-sorted-array/" target="_blank" rel="noopener">leetcode.com/problems/check-if-a-number-is-majority-element-in-a-sorted-array</a></cite></footer></blockquote>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMajorityElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>] == target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (i == len-<span class="number">1</span> || nums[i+<span class="number">1</span>] != target) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i-index+<span class="number">1</span> &gt; len/<span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Majority</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP协议</title>
    <url>/2020/05/16/HTTP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）。<br>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。</p>
<h4 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h4><ul>
<li>GET：请求指定的页面信息，并返回实体主体。</li>
<li>HEAD：类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</li>
<li>POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</li>
<li>PUT ：从客户端向服务器传送的数据取代指定的文档的内容。</li>
<li>DELETE：请求服务器删除指定的页面。</li>
<li>CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</li>
<li>OPTIONS：允许客户端查看服务器的性能。</li>
<li>TRACE：回显服务器收到的请求，主要用于测试或诊断。</li>
</ul>
<h4 id="HTTP工作原理"><a href="#HTTP工作原理" class="headerlink" title="HTTP工作原理"></a>HTTP工作原理</h4><p>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p>
<h4 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h4><p>HTTP与HTTPS有什么区别？<br>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</p>
<p>HTTPS和HTTP的区别主要如下：</p>
<ul>
<li>https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</li>
<li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li>
<li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li>
<li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li>
</ul>
<h3 id="TCP-三次握手与四次挥手"><a href="#TCP-三次握手与四次挥手" class="headerlink" title="TCP 三次握手与四次挥手"></a>TCP 三次握手与四次挥手</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>1.第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。<br>2.第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。<br>3.第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。<br>可能存在问题：SYN攻击</p>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>所谓四次挥手（Four-Way Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发。</p>
<h3 id="TCP中流量控制机制——滑动窗口"><a href="#TCP中流量控制机制——滑动窗口" class="headerlink" title="TCP中流量控制机制——滑动窗口"></a>TCP中流量控制机制——滑动窗口</h3><p>发送窗口的大小取决于接受窗口。<br>可以有效防止主机性能差距较大时造成的拥塞。</p>
<ul>
<li>地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。</li>
<li>域名系统（Domain Name System缩写DNS，Domain Name被译为域名）是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。</li>
</ul>
<h3 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h3><p>HTTP/2 的主要目标是改进传输性能，更有效地利用网络资源，实现低延迟和高吞吐量。从另一方面看，HTTP 的高层协议语义并不会因为这次版本升级而受影响。所有HTTP 首部、值，以及它们的使用场景都不会变。<br>HTTP/2 致力于突破上一代标准众所周知的性能限制，但它也是对之前1.x 标准的扩展，而非替代。之所以要递增一个大版本到2.0，主要是因为它改变了客户端与服务器之间交换数据的方式</p>
<h4 id="多路复用-Multiplexing"><a href="#多路复用-Multiplexing" class="headerlink" title="多路复用 (Multiplexing)"></a>多路复用 (Multiplexing)</h4><p>多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。有了新的分帧机制后，HTTP/2 不再依赖多个TCP 连接去实现多流并行了。每个数据流都拆分成很多互不依赖的帧，而这些帧可以交错（乱序发送），还可以分优先级。最后再在另一端把它们重新组合起来。HTTP 2.0 连接都是持久化的，而且客户端与服务器之间也只需要一个连接（每个域名一个连接）即可</p>
<h3 id="HTTP3"><a href="#HTTP3" class="headerlink" title="HTTP3"></a>HTTP3</h3><p>IETF中的QUIC工作组致力于创建QUIC传输协议。QUIC是通过UDP完成的TCP替换。</p>
<h4 id="Quic"><a href="#Quic" class="headerlink" title="Quic"></a>Quic</h4><p>Quic(QuickUDP Internet Connections)是一种新的传输方式，与TCP相比，它减少了延迟。表面上，Quic非常类似于在UDP上实现的TCP+TLS+HTTP/2。由于TCP是在操作系统内核和中间件固件中实现的，因此对TCP进行重大更改几乎是不可能的。然而，由于Quic是构建在UDP之上的，所以它没有受到这样的限制。<br>Quic在现有TCP+TLS+HTTP 2上的关键特性包括<br>大大缩短连接建立时间<br>改进的拥塞控制<br>无线头阻塞的多路复用<br>前向纠错<br>连接迁移</p>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>SSL, TLS</p>
<ol>
<li>先进行秘钥和加密算法的协商（非密文）</li>
<li>非对称密码RSA进行会话秘钥的加密</li>
<li>使用会话秘钥（对称加密）进行加密</li>
</ol>
]]></content>
      <categories>
        <category>计算机基础知识</category>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>Best Time to Buy and Sell Stock</title>
    <url>/2020/05/15/Best-Time-to-Buy-and-Sell-Stock/</url>
    <content><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote><p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.<br>Note that you cannot sell a stock before you buy one.</p>
<p>Example 1:<br>Input: [7,1,5,3,6,4]<br>Output: 5<br>Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.Not 7-1 = 6, as selling price needs to be larger than buying price.</p>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">leetcode.com/problems/best-time-to-buy-and-sell-stock</a></cite></footer></blockquote>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@param: int[] prices</span></span><br><span class="line"><span class="comment">@return: int</span></span><br><span class="line"><span class="comment">Algorithm: 记录最小价值，和之后的最大值，计算最大差值max即可。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( prices.length &lt;= <span class="number">1</span> ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> min = prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> ( prices[i] &lt; min)&#123;</span><br><span class="line">            min = prices[i];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            max = Math.max(max, prices[i] - min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Stock</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程池</title>
    <url>/2020/05/16/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>管理线程，避免增加创建线程和销毁线程的资源损耗。因为线程其实也是一个对象，创建一个对象，需要经过类加载过程，销毁一个对象，需要走GC垃圾回收流程，都是需要资源开销的。<br>提高响应速度。 如果任务到达了，相对于从线程池拿线程，重新去创建一条线程执行，速度肯定慢很多。<br>重复利用。 线程用完，再放回池子，可以达到重复利用的效果，节省资源。</p>
<h4 id="线程池参数"><a href="#线程池参数" class="headerlink" title="线程池参数"></a>线程池参数</h4><ul>
<li>corePoolSize：指定了线程池中的线程数量。</li>
<li>maximumPoolSize：指定了线程池中的最大线程数量。</li>
<li>keepAliveTime：当线程池线程数量超过corePoolSize时，多余的空闲线程的存活时间，即超过corePoolSize的空闲线程，在多长时间内会被销毁。</li>
<li>unit：keepAliveTime的单位。</li>
<li>workQueue：任务队列，被提交但尚未被执行的任务。</li>
<li>threadFactory：线程工厂，用于创建线程，一般用默认的即可。</li>
<li>handler：拒绝策略。当任务太多来不及处理时，如何拒绝任务。<h4 id="线程池类型"><a href="#线程池类型" class="headerlink" title="线程池类型"></a>线程池类型</h4></li>
<li>newFixedThreadPool (固定数目线程的线程池)</li>
<li>newCachedThreadPool(可缓存线程的线程池)</li>
<li>newSingleThreadExecutor(单线程的线程池)</li>
<li>newScheduledThreadPool(定时及周期执行的线程池)</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础知识</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>HeapSort</title>
    <url>/2020/05/16/HeapSort/</url>
    <content><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote><p>Build a heap using array. Sort an array by the heap</p>
</blockquote>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> arr[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build heap (rearrange array)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        heapify(arr, n, i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// One by one extract an element from heap</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=n-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Move current root to end</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[<span class="number">0</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// call max heapify on the reduced heap</span></span><br><span class="line">        heapify(arr, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> largest = i; <span class="comment">// Initialize largest as root</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">2</span>*i + <span class="number">1</span>; <span class="comment">// left = 2*i + 1</span></span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">2</span>*i + <span class="number">2</span>; <span class="comment">// right = 2*i + 2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// If left child is larger than root</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt; n &amp;&amp; arr[l] &gt; arr[largest])</span><br><span class="line">        largest = l;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If right child is larger than largest so far</span></span><br><span class="line">    <span class="keyword">if</span> (r &lt; n &amp;&amp; arr[r] &gt; arr[largest])</span><br><span class="line">        largest = r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If largest is not root</span></span><br><span class="line">    <span class="keyword">if</span> (largest != i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> swap = arr[i];</span><br><span class="line">        arr[i] = arr[largest];</span><br><span class="line">        arr[largest] = swap;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Recursively heapify the affected sub-tree</span></span><br><span class="line">        heapify(arr, n, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>杂题</category>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>Sort</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>Java虚拟机</title>
    <url>/2020/05/16/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><ul>
<li>程序计数器</li>
<li>虚拟机栈（java方法服务）与本地方法栈（native方法服务）</li>
<li>堆区 存放实例对象  可达性算法</li>
<li>方法区 (已被加载的类信息，常量，静态变量）运行时常量池（方法区一部分）</li>
<li>直接内存（NIO）</li>
</ul>
<h3 id="对象创建："><a href="#对象创建：" class="headerlink" title="对象创建："></a>对象创建：</h3><p>new 对象<br>检测常量池符号引用是否存在<br>检测这个类是否加载，解析初始化</p>
<ul>
<li>堆分配内存（指针碰撞法，空闲列表法) CMS使用 空闲列表</li>
<li>并发 CAS实现原子性,每个线程分配内存， TLAB实现线程同步安全</li>
<li>内存初始化为0；（实例字段不赋初值也可以用）</li>
<li>虚拟机层面完成了对象初始化，之后<init>来执行代码初始化<br>对象头(hashcode, GC分代年龄，锁标志，线程持有锁， 时间戳等）</li>
</ul>
<h3 id="OOM-（out-of-memory）"><a href="#OOM-（out-of-memory）" class="headerlink" title="OOM （out of memory）"></a>OOM （out of memory）</h3><p>堆区（new object)<br>栈区（stackOverflow, 可以多并发一直建Thread导致OOM）<br>方法区与常量池区（一直new String（i++).intern()<br>直接内存溢出：NIO</p>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>程序计数器，虚拟机栈，本地方法栈随线程自动回收</p>
<p>可达性算法的GC root：<br>虚拟机栈引用对象<br>方法区中静态对象<br>方法区常量引用对象<br>JNI引用对象（native方法）</p>
<p>相互引用要看是否挂在root上。如果是独立的循环闭环，则也会被GC。</p>
<p>引用类型：</p>
<ul>
<li>强引用</li>
<li>软引用</li>
<li>弱引用</li>
<li>虚引用</li>
</ul>
<p>// 可达性分析不可达的对象 要先判断是否finalize() （不同于try finally)</p>
<h4 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h4><ol>
<li>标记清除算法（低效率，内存碎片）</li>
<li>复制算法（内存缩小一半）<br>Eden survivor0 -&gt;survivor1 , 回收Eden survivor0 （E:s0:s1  8:1:1）</li>
<li>标记整理</li>
<li>分代回收</li>
</ol>
<h4 id="垃圾级收集器"><a href="#垃圾级收集器" class="headerlink" title="垃圾级收集器"></a>垃圾级收集器</h4><ol>
<li>Serial收集器</li>
<li>ParNew收集器  serial收集器的多线程版本</li>
<li>Paraller Scavenge收集器 复制算法</li>
<li>Serial old  标记整理算法</li>
<li>Parallel Scavenge</li>
<li>CMS 老年代收集器  标记清除算法 造成内存碎片</li>
<li>G1 标记整理算法  降低停顿时间<br>垃圾收集器：<br>{<br> ParNew 复制算法<br> Parallel Scavenge自适应收集器<br> CMS收集器并发收集器 老年代收集器 标记清除算法 内存碎片 内存整理<br> G1收集器 标记整理 Region 并发标记 清除<br>}</li>
</ol>
<h4 id="内存分配与内存回收策略"><a href="#内存分配与内存回收策略" class="headerlink" title="内存分配与内存回收策略"></a>内存分配与内存回收策略</h4><ol>
<li>Eden区中分配</li>
<li>Eden区不够时 Minor GC 或者  Eden : survivor0 : survivor1 = 8:1:1</li>
<li>大对象直接进入老生代 </li>
<li>长期存活的对象将进入老生代（年龄计数器）<br>Full GC：<br>a) 年老代（Tenured）被写满<br>b) 持久代（Perm）被写满<br>c) System.gc()被调用<br>d) 上一次GC之后Heap的各域分配策略动态变化</li>
</ol>
<p>-Xss调整内存大小</p>
<h3 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h3><ul>
<li>新生代GC频繁发生，很明显是由于虚拟机分配给新生代的空间太小而导致的，Eden区加上一个Survivor区还不到35MB。因此很有必要使用Xmn参数调整新生代的大小。</li>
<li>老生代频繁扩容引起时，调大老生代内存，每次Full Gc老年代都会扩容，但是有时是没有必要的，所以-XX设置成固定值</li>
</ul>
<p>SafePoint每次垃圾收集用户线程必须到最近的safepoint挂起然后等待回收，之后线程恢复</p>
<p>虚拟机执行字节码，字节码中包含操作码</p>
<h3 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h3><p>类型的加载，链接（验证、准备、解析），初始化</p>
<p>类加载时机{<br>加载、验证、准备、解析、初始化、使用和卸载<br>}</p>
<p>类加载触发：</p>
<ol>
<li>读取一个New关键字实例化的时候，读取设置静态字段，调用静态方法（final修饰的静态字段，已经在编译期放在了常量池除外）（static修饰的静态方法)</li>
<li>反射调用的时候，如果没有初始化，则初始化</li>
<li>父类没有初始化，则进行初始化</li>
<li>先进行主类main初始化</li>
</ol>
<p>静态变量会导致类的初始化，常量则直接在常量池中，不会导致类的初始化</p>
<p>类加载详细过程（方法区）：</p>
<ol>
<li>通过类名获取二进制流</li>
<li>静态存储结构-》方法区</li>
<li>内存中生成对象，作为方法区的访问入口<br>加载器 启动类加载器，扩展类加载器，应用程序类加载器</li>
</ol>
<p>验证：保证运行安全(NoSuchMethodError)</p>
<p>准备：方法区分配内存给静态变量，（不包括实例化对象）</p>
<p>解析：将常量池中的符合替换用直接引用<br>类和接口解析，字段解析，方法解析</p>
<p>初始化阶段<br>执行类构造器<clinit></p>
<h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>类加载器的双亲委派模型：除了顶层的启动类加载器，其余类都应有自己的父类加载器<br>过程：如果一个类加载器收到了类加载请求，首先委派给父类加载器完成。Object为顶层加载器。这样可以统一Object类避免造成混乱</p>
<p>破坏双亲委派模型：父类需要调用子类的时候<br>例如调用JDBC的JDK driver connector 会使用SPI破坏双亲委派模型，线程上下文加载器</p>
<h3 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="headerlink" title="虚拟机字节码执行引擎"></a>虚拟机字节码执行引擎</h3><p>运行时栈帧</p>
<ul>
<li>局部变量表</li>
<li>操作数栈 </li>
<li>动态连接</li>
<li>方法返回地址</li>
</ul>
<p>局部变量表：存放方法参数，方法内部定义的局部变量</p>
<p>编译</p>
<ul>
<li>解析与填充符号表 -&gt;语法树 tree结构</li>
<li>注解处理器</li>
<li>语义分析与字节码生成 执行<clinit> 与<init>方法</li>
</ul>
<p>语法糖</p>
<ul>
<li>泛型和类型擦除</li>
<li>自动装箱、拆箱和循环遍历</li>
</ul>
<p>运行与测试<br>Javac -processer</p>
<p>编译优化技术</p>
<ul>
<li>公共子表达式消除</li>
<li>数组边界检测消除</li>
<li>方法内联</li>
<li>逃逸分析（如果一个方法没有被其他外部方法调用，则可以分配到栈内存，只供当前线程使用，否则就分配到堆内存，线程共享）</li>
</ul>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>Synchronized 内部使用monitorenter monitorexit 和锁计数器来实现<br>RentrantLock重入锁<br>CAS</p>
<h4 id="volitle防止指令重排"><a href="#volitle防止指令重排" class="headerlink" title="volitle防止指令重排"></a>volitle防止指令重排</h4><p>volatile关键字通过提供“内存屏障”的方式来防止指令被重排序，为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p>
<p>大多数的处理器都支持内存屏障的指令。</p>
<p>对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能，为此，Java内存模型采取保守策略。下面是基于保守策略的JMM内存屏障插入策略：</p>
<h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><p>自旋锁和自适应锁<br>锁消除（依靠逃逸分析技术，判断如果数据不会被其他线程访问）<br>锁粗化  内部操作锁比较多，就直接给整体加一个锁<br>轻量级锁CAS操作<br>偏向锁</p>
]]></content>
      <categories>
        <category>计算机基础知识</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Majority Element II</title>
    <url>/2020/05/15/Majority-Element-II/</url>
    <content><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote><p>Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.</p>
<p>Note: The algorithm should run in linear time and in O(1) space.</p>
<p>Example:<br>Input: [3,2,3]<br>Output: [3]</p>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/majority-element-ii/" target="_blank" rel="noopener">leetcode.com/problems/majority-element-ii</a></cite></footer></blockquote>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">最多2个出现次数超过n/3的元素</span></span><br><span class="line"><span class="comment">算法：类似于Majority Element I, 用两个count， 如果重复则++， 反之--；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> count1 = <span class="number">0</span>, count2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">0</span>, num2 = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums[i];</span><br><span class="line">        <span class="keyword">if</span> (count1 == <span class="number">0</span> &amp;&amp; num2 != n) &#123;</span><br><span class="line">            num1 = n;</span><br><span class="line">            count1++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (num1 == n) &#123;</span><br><span class="line">            count1++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (count2 == <span class="number">0</span>) &#123;</span><br><span class="line">            num2 = n;</span><br><span class="line">            count2++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (num2 == n) &#123;</span><br><span class="line">            count2++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            count1--;</span><br><span class="line">            count2--;</span><br><span class="line">        &#125;            </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//最后得到num1,num2不一定是正解，再循环验证一遍</span></span><br><span class="line">    count1 = <span class="number">0</span>;</span><br><span class="line">    count2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == num1) &#123;</span><br><span class="line">            count1++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == num2) &#123;</span><br><span class="line">            count2++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count1 &gt; nums.length/<span class="number">3</span>) &#123;</span><br><span class="line">        result.add(num1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count2 &gt; nums.length/<span class="number">3</span> &amp;&amp; num1 != num2) &#123;</span><br><span class="line">        result.add(num2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Majority</tag>
      </tags>
  </entry>
  <entry>
    <title>Majority Element</title>
    <url>/2020/05/15/Majority-Element/</url>
    <content><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote><p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p>
<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>
<p>Example:<br>Input: [3,2,3]<br>Output: 3</p>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/majority-element/" target="_blank" rel="noopener">leetcode.com/problems/majority-element</a></cite></footer></blockquote>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Algorithm: 某一元素次数大于一半，将数组里看成两种元素，一种是res，另一种是非res。</span></span><br><span class="line"><span class="comment">记录一个count和对应的num，如果后面元素相等，则count++,反之--，最后count &gt;= 1则num记为res</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>, curMajority = <span class="number">0</span>;        </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            curMajority = num;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (num == curMajority) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curMajority;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Majority</tag>
      </tags>
  </entry>
  <entry>
    <title>Max Area of Island</title>
    <url>/2020/05/16/Max-Area-of-Island/</url>
    <content><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote><p>Given a non-empty 2D array grid of 0’s and 1’s, an island is a group of 1’s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.</p>
<a id="more"></a>
<p>Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)</p>
<p>Example 1:<br>[[0,0,1,0,0,0,0,1,0,0,0,0,0],<br> [0,0,0,0,0,0,0,1,1,1,0,0,0],<br> [0,1,1,0,1,0,0,0,0,0,0,0,0],<br> [0,1,0,0,1,1,0,0,1,0,1,0,0],<br> [0,1,0,0,1,1,0,0,1,1,1,0,0],<br> [0,0,0,0,0,0,0,0,0,0,1,0,0],<br> [0,0,0,0,0,0,0,1,1,1,0,0,0],<br> [0,0,0,0,0,0,0,1,1,0,0,0,0]]<br>Given the above grid, return 6. Note the answer is not 11, because the island must be connected 4-directionally</p>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/max-area-of-island/" target="_blank" rel="noopener">leetcode.com/problems/max-area-of-island</a></cite></footer></blockquote>

<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">dfs</span></span><br><span class="line"><span class="comment">*/</span>    </span><br><span class="line"><span class="keyword">int</span> row;</span><br><span class="line"><span class="keyword">int</span> col;</span><br><span class="line"><span class="keyword">int</span> result;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    row = grid.length;</span><br><span class="line">    col = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[row][col];</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span> &amp;&amp; !visited[i][j]) &#123;</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">                dfs(i, j, grid, visited);</span><br><span class="line">                result = Math.max(result, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[][] grid, <span class="keyword">boolean</span>[][] visited)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= row || j &gt;= col || visited[i][j] || grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">    count++;</span><br><span class="line">    dfs(i+<span class="number">1</span>, j, grid, visited);</span><br><span class="line">    dfs(i-<span class="number">1</span>, j, grid, visited);</span><br><span class="line">    dfs(i, j+<span class="number">1</span>, grid, visited);</span><br><span class="line">    dfs(i, j-<span class="number">1</span>, grid, visited);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">BFS</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    Node(<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">int</span> row;</span><br><span class="line"><span class="keyword">int</span> col;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    row = grid.length;</span><br><span class="line">    col = grid[<span class="number">0</span>].length;</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[row][col];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span> &amp;&amp; !visited[i][j]) &#123;</span><br><span class="line">                queue.add(<span class="keyword">new</span> Node(i,j));</span><br><span class="line">                visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                BFS(queue, visited, grid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Queue&lt;Node&gt; queue, <span class="keyword">boolean</span>[][] visited, <span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dirX = &#123;<span class="number">0</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] dirY = &#123;<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        Node cur = queue.poll();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextX = cur.x+dirX[i];</span><br><span class="line">            <span class="keyword">int</span> nextY = cur.y+dirY[i];</span><br><span class="line">            <span class="keyword">if</span> (isValid(nextX, nextY, grid, visited)) &#123;</span><br><span class="line">                visited[nextX][nextY] = <span class="keyword">true</span>;</span><br><span class="line">                queue.add(<span class="keyword">new</span> Node(nextX, nextY));</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    num = Math.max(num, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span>[][] grid, <span class="keyword">boolean</span>[][] visited)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; x &lt; row &amp;&amp; y &lt; col &amp;&amp; !visited[x][y] &amp;&amp; grid[x][y] == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Matrix</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Median Of Two Sorted Arrays</title>
    <url>/2020/05/14/Median-Of-Two-Sorted-Arrays/</url>
    <content><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote><p>There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
<p>You may assume nums1 and nums2 cannot be both empty.<br>Example 1:<br>nums1 = [1, 3]<br>nums2 = [2]<br>The median is 2.0</p>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">leetcode.com/problems/median-of-two-sorted-arrays</a></cite></footer></blockquote>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@param: int[] nums1, int[] nums2: input two sorted array;</span></span><br><span class="line"><span class="comment">@return: median.</span></span><br><span class="line"><span class="comment">Algorithm: can be expended to find kth smallest element in two sorted array;</span></span><br><span class="line"><span class="comment">in this case, median is k/2;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//corner case</span></span><br><span class="line">    <span class="keyword">if</span> (nums1.length == <span class="number">0</span> &amp;&amp; nums2.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = nums1.length + nums2.length;</span><br><span class="line">    <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (findKthNumber(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, k/<span class="number">2</span>) +</span><br><span class="line">                findKthNumber(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, k/<span class="number">2</span>+<span class="number">1</span>)) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> findKthNumber(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, k/<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//find kth Number not index, index should be k-1;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthNumber</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> startOfA,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int</span>[] B, <span class="keyword">int</span> startOfB,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (startOfA &gt;= A.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> B[startOfB + k-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (startOfB &gt;= B.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> A[startOfA + k-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// should consider last case;</span></span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.min(A[startOfA], B[startOfB]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> halfOfA = (startOfA + k/<span class="number">2</span>-<span class="number">1</span> &gt;= A.length) ? Integer.MAX_VALUE : A[startOfA + k/<span class="number">2</span>-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> halfOfB = (startOfB + k/<span class="number">2</span>-<span class="number">1</span> &gt;= B.length) ? Integer.MAX_VALUE : B[startOfB + k/<span class="number">2</span>-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// be careful here, start should be index + number(not index),</span></span><br><span class="line">    <span class="comment">// next k should be k - k/2 (not k/2);</span></span><br><span class="line">    <span class="keyword">if</span> (halfOfA &lt; halfOfB) &#123;</span><br><span class="line">        <span class="keyword">return</span> findKthNumber(A, startOfA + k/<span class="number">2</span>, B, startOfB, k - k/<span class="number">2</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> findKthNumber(A, startOfA, B, startOfB + k/<span class="number">2</span>, k - k/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Kth</tag>
      </tags>
  </entry>
  <entry>
    <title>Reveal Cards In Increasing Order</title>
    <url>/2020/05/16/Reveal-Cards-In-Increasing-Order/</url>
    <content><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote><p>In a deck of cards, every card has a unique integer.  You can order the deck in any order you want.</p>
<p>Initially, all the cards start face down (unrevealed) in one deck.</p>
<a id="more"></a>
<p>Now, you do the following steps repeatedly, until all cards are revealed:</p>
<p>Take the top card of the deck, reveal it, and take it out of the deck.<br>If there are still cards in the deck, put the next top card of the deck at the bottom of the deck.<br>If there are still unrevealed cards, go back to step 1.  Otherwise, stop.<br>Return an ordering of the deck that would reveal the cards in increasing order.</p>
<p>The first entry in the answer is considered to be the top of the deck.</p>
<p>Example 1:</p>
<p>Input: [17,13,11,2,3,5,7]<br>Output: [2,13,3,11,5,17,7]<br>Explanation:<br>We get the deck in the order [17,13,11,2,3,5,7] (this order doesn’t matter), and reorder it.<br>After reordering, the deck starts as [2,13,3,11,5,17,7], where 2 is the top of the deck.<br>We reveal 2, and move 13 to the bottom.  The deck is now [3,11,5,17,7,13].<br>We reveal 3, and move 11 to the bottom.  The deck is now [5,17,7,13,11].<br>We reveal 5, and move 17 to the bottom.  The deck is now [7,13,11,17].<br>We reveal 7, and move 13 to the bottom.  The deck is now [11,17,13].<br>We reveal 11, and move 17 to the bottom.  The deck is now [13,17].<br>We reveal 13, and move 17 to the bottom.  The deck is now [17].<br>We reveal 17.<br>Since all the cards revealed are in increasing order, the answer is correct.</p>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/reveal-cards-in-increasing-order/" target="_blank" rel="noopener">leetcode.com/problems/reveal-cards-in-increasing-order</a></cite></footer></blockquote>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@param: int[] deck 初始牌的堆放</span></span><br><span class="line"><span class="comment">@return: int[] 可以按照规则得到increading order牌的顺序</span></span><br><span class="line"><span class="comment">Algorithm: 先排序然后逆思路从大到小放一边</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] deckRevealedIncreasing(<span class="keyword">int</span>[] deck) &#123;</span><br><span class="line">    <span class="keyword">if</span> (deck.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> deck;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Arrays.sort(deck); </span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(deck[deck.length-<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = deck.length-<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        queue.add(queue.poll());</span><br><span class="line">        queue.add(deck[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = deck.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        deck[i--] = queue.poll();    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> deck;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Queue</tag>
        <tag>Deque</tag>
      </tags>
  </entry>
  <entry>
    <title>Summary Ranges</title>
    <url>/2020/05/16/Summary-Ranges/</url>
    <content><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote><p>Given a sorted integer array without duplicates, return the summary of its ranges.</p>
<p>Example 1:<br>Input:  [0,1,2,4,5,7]<br>Output: [“0-&gt;2”,”4-&gt;5”,”7”]<br>Explanation: 0,1,2 form a continuous range; 4,5 form a continuous range.</p>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/summary-ranges/" target="_blank" rel="noopener">leetcode.com/problems/summary-ranges</a></cite></footer></blockquote>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@param: int[] nums</span></span><br><span class="line"><span class="comment">@return: List&lt;String&gt;: ranges</span></span><br><span class="line"><span class="comment">Algorithm: 维护一个start,check if nums[i] = nums[i-1]+1,如果不是更新start,add result；</span></span><br><span class="line"><span class="comment">stringBuilder效率更高</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">summaryRanges</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> start = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == nums[i-<span class="number">1</span>] + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;                </span><br><span class="line">            <span class="keyword">if</span> (nums[i-<span class="number">1</span>] == start) &#123;</span><br><span class="line">                add(start, start, result);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                add(start, nums[i-<span class="number">1</span>], result);</span><br><span class="line">            &#125;                                </span><br><span class="line">            start = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[nums.length-<span class="number">1</span>] == start) &#123;</span><br><span class="line">        add(start, start, result);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        add(start, nums[nums.length-<span class="number">1</span>], result);</span><br><span class="line">    &#125;      </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, List&lt;String&gt; result)</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">if</span> (end == start) &#123;</span><br><span class="line">        sb.append(start);</span><br><span class="line">        result.add(sb.toString());</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        sb.append(start);</span><br><span class="line">        sb.append(<span class="string">"-&gt;"</span>);</span><br><span class="line">        sb.append(end);</span><br><span class="line">        result.add(sb.toString());</span><br><span class="line">    &#125;         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
  </entry>
  <entry>
    <title>Task Scheduler</title>
    <url>/2020/05/14/Task-Scheduler/</url>
    <content><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote><p>Given a char array representing tasks CPU need to do. It contains capital letters A to Z where different letters represent different tasks. Tasks could be done without original order. Each task could be done in one interval. For each interval, CPU could finish one task or just be idle.</p>
<p>However, there is a non-negative cooling interval n that means between two same tasks, there must be at least n intervals that CPU are doing different tasks or just be idle.</p>
<p>You need to return the least number of intervals the CPU will take to finish all the given tasks.</p>
<p>Example:<br>Input: tasks = [“A”,”A”,”A”,”B”,”B”,”B”], n = 2<br>Output: 8<br>Explanation: A -&gt; B -&gt; idle -&gt; A -&gt; B -&gt; idle -&gt; A -&gt; B.</p>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/task-scheduler/" target="_blank" rel="noopener">leetcode.com/problems/task-scheduler</a></cite></footer></blockquote>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">A math problem, what matter is numbers of letter that counts most;</span></span><br><span class="line"><span class="comment">AAABBB</span></span><br><span class="line"><span class="comment">A~~A~~AB</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="keyword">char</span>[] tasks, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tasks.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> tasks.length;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[] num = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> t : tasks) &#123;</span><br><span class="line">        num[t-<span class="string">'A'</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Arrays.sort(num);</span><br><span class="line">    <span class="comment">// calculater numbers of letter that counts most; in this case, 2;</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">25</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; num[i] == num[<span class="number">25</span>]) &#123;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// compare with tasks.length;</span></span><br><span class="line">    <span class="comment">// num[25]-1 is interval;</span></span><br><span class="line">    <span class="comment">// n+1 means A~~A~~, 出现次数最多的字母A，A最后一组之前的数量，</span></span><br><span class="line">    <span class="comment">//再加上与A相同的字母的数量 25-i</span></span><br><span class="line">    <span class="keyword">return</span> Math.max(tasks.length, (num[<span class="number">25</span>]-<span class="number">1</span>) * (n+<span class="number">1</span>) + <span class="number">25</span>-i);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>Mathematics</tag>
      </tags>
  </entry>
  <entry>
    <title>Two Sum</title>
    <url>/2020/05/14/Two-Sum/</url>
    <content><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>
<p>Example:<br>Given nums = [2, 7, 11, 15], target = 9,<br>Because nums[0] + nums[1] = 2 + 7 = 9,<br>return [0, 1].</p>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">leetcode.com/problems/two-sum</a></cite></footer></blockquote>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">hashmap</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i&lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> n = target-nums[i];</span><br><span class="line">        <span class="keyword">if</span> ( map.containsKey(n) )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;map.get(n),i&#125;;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Sum</tag>
      </tags>
  </entry>
  <entry>
    <title>Unique Paths III</title>
    <url>/2020/05/17/Unique-Paths-III/</url>
    <content><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote><p>On a 2-dimensional grid, there are 4 types of squares:</p>
<p>1 represents the starting square.  There is exactly one starting square.<br>2 represents the ending square.  There is exactly one ending square.</p>
<a id="more"></a>
<p>0 represents empty squares we can walk over.<br>-1 represents obstacles that we cannot walk over.<br>Return the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once.</p>
<p>Example 1:</p>
<p>Input: [[1,0,0,0],[0,0,0,0],[0,0,2,-1]]<br>Output: 2<br>Explanation: We have the following two paths: </p>
<ol>
<li>(0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)</li>
<li>(0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)</li>
</ol>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/unique-paths-iii/" target="_blank" rel="noopener">leetcode.com/problems/unique-paths-iii</a></cite></footer></blockquote>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@param: int[][] grid</span></span><br><span class="line"><span class="comment">@return: int</span></span><br><span class="line"><span class="comment">Algorithm: 常规DFS+backtracking</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> res, todo = <span class="number">1</span>, sx, sy, ex, ey, row, col;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsIII</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    row = grid.length;</span><br><span class="line">    col = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">if</span> (row == <span class="number">0</span> || col == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                todo++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                sx = i;</span><br><span class="line">                sy = j;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>) &#123;</span><br><span class="line">                ex = i;</span><br><span class="line">                ey = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(sx, sy, grid);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt;= row || y &gt;= col || grid[x][y] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x == ex &amp;&amp; y == ey ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (todo == <span class="number">0</span>)&#123;</span><br><span class="line">            res++;                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    todo--;</span><br><span class="line">    grid[x][y] = -<span class="number">2</span>;</span><br><span class="line">    dfs(x+<span class="number">1</span>,y,grid);</span><br><span class="line">    dfs(x-<span class="number">1</span>,y,grid);</span><br><span class="line">    dfs(x,y+<span class="number">1</span>,grid);</span><br><span class="line">    dfs(x,y-<span class="number">1</span>,grid);</span><br><span class="line">    todo++;</span><br><span class="line">    grid[x][y] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Matrix</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>字节跳动</title>
    <url>/2020/05/17/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8/</url>
    <content><![CDATA[<p>在2020年1月15日左右找人内推简历，第二天收到HR面试邀请，约了2月上旬，面试岗位：Java后台研发实习（广告业务组）。</p>
<h3 id="一面技术面（约60分钟）"><a href="#一面技术面（约60分钟）" class="headerlink" title="一面技术面（约60分钟）"></a>一面技术面（约60分钟）</h3><ol>
<li>简单自我介绍</li>
<li>关于项目介绍，期间提到并发多线程，所以面试官引出一个问题</li>
<li>写一个变量i++的代码，要求保证线程同步。<br>——类似于读写锁，楼主用Synchronized 给 object方法写了Lock() 和 UnLock()锁实现。<br>追问：锁的机制是如何实现的：object锁还是方法锁？<br>——回答的object锁，感觉面试官反馈不太对，也没有追问了。</li>
<li>Http协议，详细介绍下浏览器输入<a href="http://www.baidu.com之后的过程" target="_blank" rel="noopener">www.baidu.com之后的过程</a><br>——DNS，GET, POST方法都涉及到了。<br>追问TCP/IP 三次握手过程，为什么需要三次？<br>—— 介绍TCP/IP过程，然后第三次保证信息同步，服务器需要知道客户端收到response的反馈<br>追问如果第三次握手丢包怎么办？<br>——服务器重新发送response一定次数，直到client回复，若超过次数则断开连接</li>
<li>为什么说TCP/IP是可靠传输？<br>——拥塞控制，超时重传，滑动窗口</li>
<li>介绍下Java GC机制<br>——计数器法，可达性算法<br>追问可达性算法<br>——GC root从跟节点树引用遍历，如果没有被引用的对象则被回收，<br>追问如何判断引用？<br>——举例创建一个object会添加一次引用<br>追问jvm如何知道什么时候回收？<br>——举例类似读写操作，可以调用System.gc()方法来触发；</li>
<li>数据库相关，SQL语句熟不熟？出了一个双表查询算平均分的题<br>——楼主表示不太熟，马马虎虎写了一个select语句，面试官也没有追问了</li>
<li>数据库事务隔离机制<br>—— 未提交读，提交读，可重复读，序列化, 分别介绍了可能存在的问题依次是脏读，不可重复度，幻读<br>追问MySQL用的哪种？<br>——可重复读<br>追问如何实现的？<br>——不太清楚，某种读写锁？<br>追问MySQL索引怎么实现？<br>——B+ Tree<br>追问能否实现以下？<br>—— 实现B+树。。。放弃，说可以解释下原理，面试官直接说不用解释了。</li>
</ol>
<p><strong>算法题：</strong> ABC全排列，dfs+backtracking秒了，少许错误</p>
<h3 id="二面技术面（约40分钟）"><a href="#二面技术面（约40分钟）" class="headerlink" title="二面技术面（约40分钟）"></a>二面技术面（约40分钟）</h3><ol>
<li>自我介绍</li>
<li>楼主之前搞安全的， 追问你知道哪些安全攻击，介绍下xss？<br>——表示某种注入攻击，具体不太熟，然后说 syn, dos, ddos可以<br>追问介绍下dos<br>——拒绝服务攻击，伪造报文向服务器发送大量请求，造成服务器过载，无法提供正常服务，ddos加分布式</li>
<li>介绍 https<br>——在http基础上添加了ssl ，对称秘钥加密体制，公钥加密，私钥解密，然后又介绍了下非对称加密</li>
<li>介绍下进程死锁<br>——4个条件：互斥，占有等待，非抢占，循环等待。分别解释了下</li>
<li>解释下Java创建一个object，如何创建的，内存怎么分配的？<br>——举例创建一个String，系统会给这个Object分配一个内存地址，然后加引用指针，然后存入value值。<br>追问equals 和 hashcode方法<br>——equals判断value是否相等，hashcode通过hash function计算，这里答的不太好…</li>
<li>介绍信Java如何实现线程同步<br>—— synchronize, lock, volatile, atomic<br>追问解释下volatile<br>——从Java 内存开始解释，然后解释了可见性，原子性，有序性<br>追问乐观锁与悲观锁<br>——乐观锁可以挂起做其他事情，悲观锁一直等待</li>
</ol>
<p><strong>算法题：</strong> trap rain，留了20分钟，楼主15分钟不到bug free秒了，用two pointers.</p>
<h3 id="三面BOSS面（约30分）"><a href="#三面BOSS面（约30分）" class="headerlink" title="三面BOSS面（约30分）"></a>三面BOSS面（约30分）</h3><ol>
<li>简单自我介绍</li>
<li>最近有看什么书啊？</li>
<li>为什么实习，之前的实习收获了什么，想从实习中学什么？</li>
<li>结束下浏览器是如何知道哪些客户的，与服务器怎么交互？<br>——cookie 和session解释了一通</li>
<li>linux熟悉哪些指令？</li>
<li>关于业务有什么想问的？</li>
</ol>
<p><strong>算法题：</strong> permution 1234 -&gt; 1243，先要求解释一下算法，大概用了8分钟，然后要求7分钟内写完代码。楼主只完成了一种case。。。</p>
<p>总体下来感觉还是比较难的，楼主面试美西时间22：00，直到凌晨0：20左右结束，三面考算法题的时候已经非常疲惫，体验一般。也是吃了一堑，后续面试都约到下午了。</p>
<p>字节是我准备回国实习后面试的第一家公司，没什么面试经验，准备也不太充分，整体表现也一般。</p>
]]></content>
      <categories>
        <category>面试</category>
        <category>2020春招</category>
      </categories>
  </entry>
  <entry>
    <title>Weekly Contest 189</title>
    <url>/2020/05/17/Weekly-Contest-189/</url>
    <content><![CDATA[<p><a href="https://leetcode.com/contest/weekly-contest-189" target="_blank" rel="noopener">https://leetcode.com/contest/weekly-contest-189</a><br><img src="/images/Weekly-Contest-189.png" alt=""></p>
<h3 id="Number-of-Students-Doing-Homework-at-a-Given-Time"><a href="#Number-of-Students-Doing-Homework-at-a-Given-Time" class="headerlink" title="Number of Students Doing Homework at a Given Time"></a>Number of Students Doing Homework at a Given Time</h3><blockquote><p>Given two integer arrays startTime and endTime and given an integer queryTime.</p>
<p>The ith student started doing their homework at the time startTime[i] and finished it at time endTime[i].</p>
<a id="more"></a>
<p>Return the number of students doing their homework at time queryTime. More formally, return the number of students where queryTime lays in the interval [startTime[i], endTime[i]] inclusive.</p>
<p>Example 1:<br>Input: startTime = [1,2,3], endTime = [3,2,7], queryTime = 4<br>Output: 1<br>Explanation: We have 3 students where:<br>The first student started doing homework at time 1 and finished at time 3 and wasn’t doing anything at time 4.<br>The second student started doing homework at time 2 and finished at time 2 and also wasn’t doing anything at time 4.<br>The third student started doing homework at time 3 and finished at time 7 and was the only student doing homework at time 4.</p>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/number-of-students-doing-homework-at-a-given-time/" target="_blank" rel="noopener">leetcode.com/problems/number-of-students-doing-homework-at-a-given-time</a></cite></footer></blockquote>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">busyStudent</span><span class="params">(<span class="keyword">int</span>[] startTime, <span class="keyword">int</span>[] endTime, <span class="keyword">int</span> queryTime)</span> </span>&#123;        </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; startTime.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (startTime[i] &lt;= queryTime &amp;&amp; endTime[i] &gt;= queryTime) &#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Rearrange-Words-in-a-Sentence"><a href="#Rearrange-Words-in-a-Sentence" class="headerlink" title="Rearrange Words in a Sentence"></a>Rearrange Words in a Sentence</h3><blockquote><p>Given a sentence text (A sentence is a string of space-separated words) in the following format:</p>
<p>First letter is in upper case.<br>Each word in text are separated by a single space.<br>Your task is to rearrange the words in text such that all words are rearranged in an increasing order of their lengths. If two words have the same length, arrange them in their original order.</p>
<p>Return the new text following the format shown above.</p>
<p>Example 1:</p>
<p>Input: text = “Leetcode is cool”<br>Output: “Is cool leetcode”<br>Explanation: There are 3 words, “Leetcode” of length 8, “is” of length 2 and “cool” of length 4.<br>Output is ordered by length and the new first word starts with capital letter.</p>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/rearrange-words-in-a-sentence/" target="_blank" rel="noopener">leetcode.com/problems/rearrange-words-in-a-sentence</a></cite></footer></blockquote>

<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">arrangeWords</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (text.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> text;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    text = (<span class="keyword">char</span>)(text.charAt(<span class="number">0</span>) + <span class="number">32</span>) + text.substring(<span class="number">1</span>,text.length());</span><br><span class="line">    String[] str = text.split(<span class="string">" "</span>,<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    Arrays.sort(str, (o1,o2) -&gt;o1.length() - o2.length());</span><br><span class="line">    </span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (String s: str) &#123;</span><br><span class="line">        res.append(s);</span><br><span class="line">        res.append(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    text = res.toString().substring(<span class="number">0</span>,res.length()-<span class="number">1</span>);</span><br><span class="line">    text = (<span class="keyword">char</span>)(text.charAt(<span class="number">0</span>) - <span class="number">32</span>) + text.substring(<span class="number">1</span>,text.length());</span><br><span class="line">    <span class="keyword">return</span> text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="People-Whose-List-of-Favorite-Companies-Is-Not-a-Subset-of-Another-List"><a href="#People-Whose-List-of-Favorite-Companies-Is-Not-a-Subset-of-Another-List" class="headerlink" title="People Whose List of Favorite Companies Is Not a Subset of Another List"></a>People Whose List of Favorite Companies Is Not a Subset of Another List</h3><blockquote><p>Given the array favoriteCompanies where favoriteCompanies[i] is the list of favorites companies for the ith person (indexed from 0).</p>
<p>Return the indices of people whose list of favorite companies is not a subset of any other list of favorites companies. You must return the indices in increasing order.</p>
<p>Example 1:<br>Input:favoriteCompanies = [[“leetcode”,”google”,”facebook”],[“google”,”microsoft”],[“google”,”facebook”],[“google”],[“amazon”]]<br>Output: [0,1,4]<br>Explanation:<br>Person with index=2 has favoriteCompanies[2]=[“google”,”facebook”] which is a subset of favoriteCompanies[0]=[“leetcode”,”google”,”facebook”] corresponding to the person with index 0.<br>Person with index=3 has favoriteCompanies[3]=[“google”] which is a subset of favoriteCompanies[0]=[“leetcode”,”google”,”facebook”] and favoriteCompanies[1]=[“google”,”microsoft”].<br>Other lists of favorite companies are not a subset of another list, therefore, the answer is [0,1,4].</p>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list/" target="_blank" rel="noopener">leetcode.com/problems/people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list</a></cite></footer></blockquote>

<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">brute force: O(n^3)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">peopleIndexes</span><span class="params">(List&lt;List&lt;String&gt;&gt; favoriteCompanies)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (favoriteCompanies.size() == <span class="number">0</span> || favoriteCompanies.get(<span class="number">0</span>).size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> size = favoriteCompanies.size();</span><br><span class="line">    Map&lt;Integer, Set&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; favoriteCompanies.size(); i++) &#123;</span><br><span class="line">        map.put(i, <span class="keyword">new</span> HashSet&lt;String&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        Set&lt;String&gt; set = map.get(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; favoriteCompanies.get(i).size(); j++) &#123;</span><br><span class="line">            set.add(favoriteCompanies.get(i).get(j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">boolean</span> exist = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        exist = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> temp = <span class="keyword">true</span>;</span><br><span class="line">            Set&lt;String&gt; cur = map.get(j);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; favoriteCompanies.get(i).size(); k++) &#123;                    </span><br><span class="line">                <span class="keyword">if</span> (!cur.contains(favoriteCompanies.get(i).get(k))) &#123;</span><br><span class="line">                    temp = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            exist = exist | temp;</span><br><span class="line">            <span class="keyword">if</span> (exist) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!exist) &#123;</span><br><span class="line">            res.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Maximum-Number-of-Darts-Inside-of-a-Circular-Dartboard"><a href="#Maximum-Number-of-Darts-Inside-of-a-Circular-Dartboard" class="headerlink" title="Maximum Number of Darts Inside of a Circular Dartboard"></a>Maximum Number of Darts Inside of a Circular Dartboard</h3><blockquote><p>You have a very large square wall and a circular dartboard placed on the wall. You have been challenged to throw darts into the board blindfolded. Darts thrown at the wall are represented as an array of points on a 2D plane. </p>
<p>Return the maximum number of points that are within or lie on any circular dartboard of radius r.</p>
<p>Example 1:<br>Input: points = [[-2,0],[2,0],[0,2],[0,-2]], r = 2<br>Output: 4<br>Explanation: Circle dartboard with center in (0,0) and radius = 2 contain all points.</p>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/maximum-number-of-darts-inside-of-a-circular-dartboard/" target="_blank" rel="noopener">leetcode.com/problems/maximum-number-of-darts-inside-of-a-circular-dartboard</a></cite></footer></blockquote>

<h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>先考虑了求三个点构成的三角形的外心，以这个点为圆心，遍历其他点，到外心的距离小于半径则记录count。<br>发现只过了40多个case，解法有问题。学习了一下，见以下解法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参考：https://seattler.io/thread-1163.htm?from=groupmessage&amp;isappinstalled=0</span></span><br><span class="line"><span class="comment">@param: int[][] points 点的坐标, r 半径</span></span><br><span class="line"><span class="comment">@return: int 最大覆盖圆的数</span></span><br><span class="line"><span class="comment">算法：假设有一个大圆可以覆盖所有的点，然后将这个大圆压缩，直到有两个点在圆上，然后根据这两个点和给定的半径确定一个圆。遍历其他点，是否在这个圆中。</span></span><br><span class="line"><span class="comment">即枚举所有的两点组合，然后结合半径求出圆心坐标，遍历其他点，与圆心的距离小于r，则count++，求max count；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">    Point() &#123;&#125;</span><br><span class="line">    Point(<span class="keyword">double</span> x, <span class="keyword">double</span> y) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">double</span> precision = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numPoints</span><span class="params">(<span class="keyword">int</span>[][] points, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (points.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (points.length == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (distance(points[<span class="number">0</span>][<span class="number">0</span>], points[<span class="number">0</span>][<span class="number">1</span>], points[<span class="number">1</span>][<span class="number">0</span>], points[<span class="number">1</span>][<span class="number">1</span>]) - r * r &lt; precision) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; points.length; j++) &#123;</span><br><span class="line">            help(<span class="keyword">new</span> Point(points[i][<span class="number">0</span>],points[i][<span class="number">1</span>]), <span class="keyword">new</span> Point(points[j][<span class="number">0</span>], points[j][<span class="number">1</span>]), r, points);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">help</span><span class="params">(Point a, Point b, <span class="keyword">int</span> r, <span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> x1 = a.x;</span><br><span class="line">        <span class="keyword">double</span> y1 = a.y;</span><br><span class="line">        <span class="keyword">double</span> x2 = b.x;</span><br><span class="line">        <span class="keyword">double</span> y2 = b.y;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">double</span> mx = (x1 + x2) / <span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">double</span> my = (y1 + y2) / <span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">double</span> dx = x1 - x2;</span><br><span class="line">        <span class="keyword">double</span> dy = y1 - y2;</span><br><span class="line">        <span class="keyword">double</span> dis = Math.sqrt(dx * dx + dy * dy);</span><br><span class="line">        <span class="keyword">double</span> disR = Math.sqrt(r * r - dis * dis / <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">double</span> dxR = -dy / dis;</span><br><span class="line">        <span class="keyword">double</span> dyR = dx / dis;</span><br><span class="line">        <span class="keyword">double</span> x = mx + (-dy/dis) * disR;</span><br><span class="line">        <span class="keyword">double</span> y = my + (dx/dis) * disR;</span><br><span class="line">        check(<span class="keyword">new</span> Point(x, y), r, points);</span><br><span class="line">        x = mx - dxR * disR;</span><br><span class="line">        y = my - dyR * disR;</span><br><span class="line">        check(<span class="keyword">new</span> Point(x, y), r, points);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(Point pr, <span class="keyword">int</span> r, <span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] p : points) &#123;</span><br><span class="line">        <span class="keyword">double</span> dx = pr.x - p[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">double</span> dy = pr.y - p[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">double</span> d = dx*dx + dy*dy - r*r;</span><br><span class="line">        <span class="keyword">if</span> (d &lt;= precision) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    max = Math.max(max, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">distance</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> d= (x1-x2) * (x1-x2) + (y1-y2) * (y1-y2);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Contest</category>
      </categories>
      <tags>
        <tag>Mathematics</tag>
        <tag>Circle</tag>
      </tags>
  </entry>
  <entry>
    <title>微软中国</title>
    <url>/2020/05/18/%E5%BE%AE%E8%BD%AF%E4%B8%AD%E5%9B%BD/</url>
    <content><![CDATA[<p>在2020年1月中旬官网海投微软苏州SDE intern，在3月上旬收到HR面试邀请。<br>微软面试主要以算法题为主，当时苏州是2轮，第一轮有2次机会，只要其中一次过了就可以进入manager面。</p>
<h4 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h4><p>一面小哥进来寒暄几句，让我简单自我介绍（中文），介绍了下项目，这部分感觉走过场，不过发挥的挺好，聊得很愉快。</p>
<p><strong>算法题</strong><br>算法题是一道场景题，以二极管数字灯为背景<br><img src="/images/%E5%BE%AE%E8%BD%AF%E4%B8%AD%E5%9B%BD.png" alt=""><br>有4个数字，每个数字由7个二极管组成（横三竖四）。由于一些原因，二极管坏掉了，所以无法发光。例如8是全部都亮，但是可能某几个二极管坏了，只显示为5，也可能是6，9。</p>
<p>问：给定4个坏掉二极管板组成的数字，求可能的数字集合。<br>例如显示为5555，每个5可能代表6，8，9三种情况，所以最后可能是3<em>3</em>3*3 = 81，返回81。</p>
<p><strong>解法:</strong><br>一开始反应有点僵，这题最难的是建模。所有的题目都是面试官口述，得跟面试官一步步确定具体题目需求，题目输入和输入都是自定义，非常考验沟通能力。</p>
<p>一步步跟面试官沟通之后，沟通的还不错，面试官给了一点提示，最后用二进制解法秒了。<br>结束后问面试官这题解法，面试官说是求subset，二进制也可以。说我能想到二进制解法非常不错了。</p>
<h4 id="Manager面"><a href="#Manager面" class="headerlink" title="Manager面"></a>Manager面</h4><p>由于一面发挥的非常好，直接给我进入Manager面，有点出乎意料。</p>
<p>Manager面直接上来二话不说就开始做题，又是一道场景题。说用中文来描述数字，例如一亿五千万六十一百万弎十五。求转成的数字。</p>
<p>乍一看没什么难度，这题其实是一道corner case题，有很多不按常规的描述。<br>先写了一个解法，面试官说有几个case过不去，后来又改了以下。然后又一种case过不去。</p>
<p>整体表现我觉得就是跟面试官沟通的不够，看一题没仔细想清楚，就闷头写代码，结果很多corner case点没有跟面试官确定清楚。导致最后改来改去，套进去出不来了，最后还被说代码写的不够优雅…</p>
<h4 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h4><p>总结经验教训，做题应该先想把逻辑想清楚，跟面试官沟通确认一些case，然后再重新整理思路，一气呵成。总之还是算法硬实力不足吧，之前没有重视题目的corner case处理，导致这次措手不及。</p>
]]></content>
      <categories>
        <category>面试</category>
        <category>2020春招</category>
      </categories>
  </entry>
  <entry>
    <title>快手</title>
    <url>/2020/05/18/%E5%BF%AB%E6%89%8B/</url>
    <content><![CDATA[<p>2020年2月底找朋友直推了快手Java研发实习， 第二天HR发来邮件，约了面试。</p>
<h4 id="一面技术面"><a href="#一面技术面" class="headerlink" title="一面技术面"></a>一面技术面</h4><ul>
<li>自我介绍</li>
<li>Spring介绍一下</li>
<li>什么是依赖注入和切面编程</li>
<li>hashmap 和 hashtable区别</li>
<li>hashmap底层实现</li>
<li>arraylist和linkedlist区别，优缺点</li>
<li>项目中为什么使用mysql</li>
<li>mysql引擎索引底层实现</li>
<li>什么时候加索引</li>
<li>Java多线程介绍一下</li>
<li>线程池参数了解吗</li>
</ul>
<p><strong>coding:</strong> 实现一下链表的反转</p>
<h4 id="二面技术面"><a href="#二面技术面" class="headerlink" title="二面技术面"></a>二面技术面</h4><p>面试官上来就做题，当时是美西时间23：00,不知道为什么当天状态特别差，非常疲惫，一道easy题想复杂了，没有做出来。</p>
<p>然后面试官问了一些关于系统设计和ood的题目，说做一个评论的点赞系统，让我考虑一下如何实现。当时没有了解太多关于系统设计的知识，以为实习范畴不会涉及。就从一些多用户并发点赞的技术实现细节回答，答了redis或者memcached缓存来优化数据库查询，redis计数器来记录点赞次数；还说到数据库读写使用乐观锁。</p>
<p>都被面试官否定了，说回答不在点上…</p>
<p>总之感觉面试体验一般，对我申请职位的考察范围与我的技能栈有些出入。那天又是接近凌晨面试，状态真的差，总之个人不太喜欢连着面好几轮，还都在晚上，对留学生不太友好。</p>
]]></content>
      <categories>
        <category>面试</category>
        <category>2020春招</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2020/05/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><p>进程：分配资源的基本单位<br>线程：独立运行和独立调度的基本单位</p>
<h4 id="进程与线程的区别："><a href="#进程与线程的区别：" class="headerlink" title="进程与线程的区别："></a>进程与线程的区别：</h4><p>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p>
<ul>
<li>一个程序至少有一个进程,一个进程至少有一个线程.</li>
<li>线程的划分尺度小于进程，使得多线程程序的并发性高。</li>
<li>进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</li>
<li>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li>
<li>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。<br>优缺点</li>
</ul>
<p>线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时，线程适合于在SMP(多核处理机)机器上运行，而进程则可以跨机器迁移。</p>
<h3 id="死锁："><a href="#死锁：" class="headerlink" title="死锁："></a>死锁：</h3><ol>
<li>互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。 </li>
<li>请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</li>
<li>不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li>
<li>环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</li>
</ol>
<h4 id="银行家算法："><a href="#银行家算法：" class="headerlink" title="银行家算法："></a>银行家算法：</h4><p>信号量<br>初始化，给与它一个非负数的整数值。<br>运行 P（wait()），信号量S的值将被减少。企图进入临界区块的进程，需要先运行 P（wait()）。当信号量S减为负值时，进程会被挡住，不能继续；当信号量S不为负值时，进程可以获准进入临界区块。<br>运行 V（又称signal()），信号量S的值会被增加。结束离开临界区块的进程，将会运行 V（又称signal()）。当信号量S不为负值时，先前被挡住的其他进程，将可获准进入临界区块。</p>
<h3 id="分页和分段的区别"><a href="#分页和分段的区别" class="headerlink" title="分页和分段的区别"></a>分页和分段的区别</h3><ul>
<li>段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的</li>
<li>段的大小不固定，有它所完成的功能决定；页大大小固定，由系统决定<br>段向用户提供二维地址空间；页向用户提供的是一维地址空间</li>
<li>段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制。</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础知识</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>腾讯</title>
    <url>/2020/05/17/%E8%85%BE%E8%AE%AF/</url>
    <content><![CDATA[<p>楼主在2020年2月投递了腾讯后台暑期研发实习生，官网直投。2周后被PCG部门捞，一共面了2轮技术面和1轮HR，3月下旬拿到offer。</p>
<h3 id="技术面试"><a href="#技术面试" class="headerlink" title="技术面试"></a>技术面试</h3><h4 id="一面技术面-60min"><a href="#一面技术面-60min" class="headerlink" title="一面技术面 60min"></a>一面技术面 60min</h4><ol>
<li>自我介绍</li>
<li>详细介绍项目，深挖简历细节</li>
<li>项目中涉及RabbitMQ/Kafka介绍一下如何实现的，为什么要用？（项目中用了RabbitMQ重点介绍了下）</li>
<li>说一下Spring，为什么用Spring</li>
<li>项目中谈到Docker，了解docker底层实现机制吗？</li>
<li>测试工具有没有用过？介绍了下JUnit，然后介绍了下之前项目是如何研发测试的</li>
<li>项目中为什么选用MySQL数据库</li>
<li>MySQL数据库隔离级别</li>
<li>数据库索引了解吗</li>
<li>说一下死锁的原因</li>
<li>倾向于做哪块，后端全栈？（因为楼主投递后端，简历有几个前端/全栈项目）</li>
</ol>
<h4 id="二面技术面-70min"><a href="#二面技术面-70min" class="headerlink" title="二面技术面 70min"></a>二面技术面 70min</h4><ol>
<li>C++了解吗（。。。楼主是java，不了解，就没细问了）</li>
<li>Linux常用命令说下</li>
<li>项目中用到maven，如何配置</li>
<li>介绍下docker常用命令，项目里docker的配置</li>
<li>docker File命令了解吗</li>
<li>项目中用到Jenkins，说一下如何配置</li>
<li>什么时候创建数据库索引，哪些字段适合创建，需要注意什么</li>
</ol>
<p><strong>算法题：</strong> 如何求出二叉搜索树的第K大节点<br><strong>算法题：</strong> 实现以下Sqrt()函数  （牛顿迭代秒了）</p>
<h3 id="HR面"><a href="#HR面" class="headerlink" title="HR面"></a>HR面</h3><ol>
<li>自我介绍</li>
<li>工作地点意向</li>
<li>平时怎么学习，除了课程之外的学习途径</li>
<li>兴趣爱好</li>
<li>你最看重公司的哪些特点</li>
<li>有没有其他公司面试</li>
</ol>
<p>总体来说难度适中，一面是个小姐姐非常nice，二面是个技术小哥，也聊得非常愉快，由于技术栈不是c++，也没有刁难，就问了很多关于基础和算法的问题。</p>
<p>重要一点是腾讯面试每次面试都分开约，我都是约的美西时间下午，这样不会由于时差导致状态差，总体面试体验很好！</p>
<p>最终决定去腾讯了，由于疫情因素没能回国，非常感谢鹅厂允许我远程实习，春招也算圆满结束了！</p>
]]></content>
      <categories>
        <category>面试</category>
        <category>2020春招</category>
      </categories>
  </entry>
  <entry>
    <title>阿里巴巴</title>
    <url>/2020/05/17/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4/</url>
    <content><![CDATA[<p>找人内推的2020暑期Java研发工程师实习生，新零售国际化事业部，共计2轮OA, 6轮技术面试+交叉面（面试过程还有2轮coding)，1轮HR面。断断续续持续了一个月，非常疲惫。</p>
<h3 id="OA-测评"><a href="#OA-测评" class="headerlink" title="OA 测评"></a>OA 测评</h3><ol>
<li>阿里在线测评主要分为四个部分：</li>
</ol>
<ul>
<li>语文</li>
<li>数字图表</li>
<li>图形推理</li>
<li>性格测试<br>前两部分是类似GRE的中文题目，图形推理主要是门萨题目里的智商测试题，最后一部分是职场性格测试。</li>
</ul>
<ol start="2">
<li>在线笔试：我当时是一道斗地主题目和一道多个array求最大合并序列。应该是一道hard和medium，斗地主类似于noip斗地主的简化版本。</li>
</ol>
<h3 id="技术面试"><a href="#技术面试" class="headerlink" title="技术面试"></a>技术面试</h3><h4 id="一面技术面-70min"><a href="#一面技术面-70min" class="headerlink" title="一面技术面 70min"></a>一面技术面 70min</h4><ul>
<li>自我介绍</li>
<li>项目深挖细节</li>
<li>项目涉及spring，spring依赖注入方式</li>
<li>spring如何创建一个bean</li>
<li>sprint boot特点</li>
<li>java如何new一个类，内存如何分配</li>
<li>双亲委派模型介绍一下</li>
<li>web项目中session和cookie如何实现的，如果浏览器禁用cookie如何处理？</li>
<li>concurrentHashMap如何实现，解决什么问题？</li>
</ul>
<p><strong>算法题：</strong>一面结束发了链接2小时写完4道题目: </p>
<ol>
<li>java运行一个cmd命令。 </li>
<li>两种写法实现单例模式。 </li>
<li>一道字母消消乐，给String：例如aABbCc，存在相邻的大小写就消除，求最后的string。</li>
<li>一道拓扑排序的图形题，下一次拓扑要求按字典顺序排序（改用priorityQueue就行了）。</li>
</ol>
<h4 id="二面技术面-72min"><a href="#二面技术面-72min" class="headerlink" title="二面技术面 72min"></a>二面技术面 72min</h4><ul>
<li>自我介绍</li>
<li>项目挖技术深度</li>
<li>jvm相关，如何实例化对象，涉及哪些内存区</li>
<li>项目用到RabbitMq，如何实现？</li>
<li>无锁队列用过没？如何实现无锁队列</li>
<li>数据库MySQL引擎介绍一下，涉及数据结构(B+ tree)</li>
<li>分布式存储了解吗？</li>
<li>项目中有redis如何用的，如何实现分布式集群？</li>
<li>项目中有react，为什么要用react，有什么优势？</li>
</ul>
<h4 id="三面主管面-70min"><a href="#三面主管面-70min" class="headerlink" title="三面主管面 70min"></a>三面主管面 70min</h4><ul>
<li>自我介绍</li>
<li>项目</li>
<li>场景题：多个线程同时访问一块资源，如何减少性能消耗？（锁优化，CAS角度回答)</li>
<li>数据库隔离级别</li>
<li>事务太消耗性能，怎么优化查询？</li>
<li>threadLocal介绍一下</li>
<li>concurrent 类包用过没？</li>
<li>英文交流了10分钟</li>
<li>课余时间如何学习，GPA怎么保持的？</li>
<li>flink有没有了解过，机器学习了解哪些?</li>
</ul>
<h4 id="四面交叉面-70min"><a href="#四面交叉面-70min" class="headerlink" title="四面交叉面 70min"></a>四面交叉面 70min</h4><ul>
<li>双亲委派模型，如何打破？</li>
<li>netty介绍一下</li>
<li>项目中用到docker，底层如何实现？</li>
<li>kafka了解吗</li>
<li>threadlocal</li>
<li>Spring代理如何实现的？</li>
<li>jvm调优，线上故障排查</li>
<li>jvm命令参数熟悉吗</li>
</ul>
<p><strong>算法题：</strong> 期间30min完成2道题目，一道单例模式，一道约瑟夫环</p>
<h4 id="五面交叉面-50min"><a href="#五面交叉面-50min" class="headerlink" title="五面交叉面 50min"></a>五面交叉面 50min</h4><ul>
<li>说一下知道的object类的方法</li>
<li>hashcode equals介绍一下，如果不覆写hashcode会怎么样</li>
<li>sleep 与 wait的区别</li>
<li>java GC，如果两个object相互引用会被清理吗？</li>
<li>场景题目：淘宝有1T数据url，只有1G内存，如何求出top 10的访问最高频率的url</li>
</ul>
<h4 id="六面交叉面-60min"><a href="#六面交叉面-60min" class="headerlink" title="六面交叉面 60min"></a>六面交叉面 60min</h4><ul>
<li>jvm和jmm介绍一下</li>
<li>哪些内存区对应缓存，哪些对应主存</li>
<li>场景题目：如何提高操作系统缓存利用率，淘宝每天的热度商品放缓存里，设计数据结构实现 （LRU cache)</li>
<li>职业规划</li>
</ul>
<h3 id="HR面"><a href="#HR面" class="headerlink" title="HR面"></a>HR面</h3><ul>
<li>有什么优缺点</li>
<li>项目中担任什么角色</li>
<li>如何学习</li>
<li>读研最大的收获</li>
</ul>
<p>阿里整体感觉还是有难度的，不过面试发挥的很好，跟几位面试官也聊得很愉快，只是流程比较慢。由于一些个人因素最后选择去鹅厂了。</p>
]]></content>
      <categories>
        <category>面试</category>
        <category>2020春招</category>
      </categories>
  </entry>
  <entry>
    <title>2020春招总结与感悟</title>
    <url>/2020/05/18/2020%E6%98%A5%E6%8B%9B%E6%80%BB%E7%BB%93%E4%B8%8E%E6%84%9F%E6%82%9F/</url>
    <content><![CDATA[<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>2020春招持续了3个多月，整体感觉下来非常疲惫，主要是由于很多不确定因素导致的心力交瘁。由于美国疫情不断加剧，导致机票被取消，再加上我的签证有效期只有一年，美国签证办理政策尚未明确，入境政策也尚未开放，回国之后也需隔离14天才能实习。综合种种因素，经过慎重考虑，我决定放弃回国，申请远程实习。最后决定去鹅厂了，幸运的是鹅厂接受我远程实习，非常感谢！</p>
<p>非常感谢春招期间帮我内推的朋友，其中有些是我的同学，有些是地里以及论坛认识的大牛，还有一些是校招宣讲会认识的HR，在他们的帮助下，很顺利拿到了面试。内推的确是拿面试非常有效的手段，所以建议大家能找内推还是尽量找内推。</p>
<p>我组建的Mock小组里的同学也基本都在去年秋招和今年春招拿到大厂的实习，期间大家相互Mock,相互分享，相互鼓励，相互吐槽，甚至时不时攒个酒局，气氛非常的和谐、愉快。很幸运能有这么一群小伙伴一起奋斗，让我想到了本科期间一起参加竞赛的队友，有这么一群朋友为了共同的目标一起努力奋斗真的是一件很幸运和开心的事情。为了紧跟大家的步伐，我也得好好练练酒量了，哈哈哈！</p>
<p>接下来的一段时间当然是实习和准备秋招了，虽然当前形势不太乐观，但是做好自己的事情，总会有好运的。疫情当下，一起努力，加油！</p>
<h3 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h3><p>面试国内企业坑点：</p>
<ul>
<li>约面试注意好时差，最好约北京时间上午，是美西时间下午，有些公司会连着面技术面和coding，太晚面试精力和状态会跟不上</li>
<li>相比外企的研发岗，国内企业会注重基础和项目，简历上的项目要吃透，提到的每一个技术点要摸清楚原理，要有被面试官刨根问底的准备</li>
<li>HR面试很关键，尤其是留学生，会问很多关于回国的事项</li>
</ul>
<p>经验总结：</p>
<ul>
<li>保持自信，面试官一定会问到你不懂的知识点，这时候不要慌，尽量按照自己的理解，结合所学知识回答</li>
<li>实在没办法回答的点，直接坦白说这块知识点不熟悉，切忌胡编乱造</li>
<li>面经可以提前刷一下，可以大概了解下面试的范围和高频面试题，但不要太依赖面经。从腾讯和阿里面试来看很多都是面经没有的点，很多都是结合简历来延伸的知识点</li>
<li>切忌表现出傲慢的姿态，面试官基本都是以后工作的师兄和leader，会给人留下一种不容易沟通的印象</li>
<li>面试其实一件看运气和缘分的事情，发挥好坏存在很多偶然因素，也得看面试官对你感不感兴趣，总之坦然对待面试结果</li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
        <category>2020春招</category>
      </categories>
  </entry>
  <entry>
    <title>前言</title>
    <url>/2020/05/14/%E5%89%8D%E8%A8%80/</url>
    <content><![CDATA[<p>大家好, 我是无尘(dustfree)，欢迎来到我的博客空间。</p>
<p>目前是一名研一学生，计算机相关专业，坐标美国西雅图。一直以来都有写文档的习惯，记录自己在学习、面试、成长过程中的心得与感悟。主要包括LeetCode刷题笔记，计算机基础知识积累，技术学习笔记，以及一些面试经验与成长心得。由于在学习过程中踩过不少坑，走了不少弯路，所以记录下来提醒自己勿犯同样的错误，同时也是一份很好的复习资料。</p>
<p>考虑到大家在学习过程中可能也会遇到同样的问题，索性将笔记分享出来，以免大家走同样的弯路，犯同样的错误。建站的初衷是为了让自己继续保持记录笔记的习惯，同时督促自己学习。如果这些笔记可以帮助到大家，再好不过了！</p>
<p>如果大家在学习过程中遇到类似的问题，欢迎发邮件与我交流。</p>
]]></content>
  </entry>
  <entry>
    <title>Spring框架</title>
    <url>/2020/05/21/Spring%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h4 id="Spring四种关键策略"><a href="#Spring四种关键策略" class="headerlink" title="Spring四种关键策略"></a>Spring四种关键策略</h4><ul>
<li>基于POJO (plain old java object) 的轻量级和最小侵入性编程</li>
<li>通过依赖注入和面向接口实现松耦合</li>
<li>基于切面和惯例进行声明式编程</li>
<li>通过切面和模板减少样版式代码 </li>
</ul>
<p>依赖注入DI </p>
<ul>
<li>构造器注入（参数中传入对象）</li>
<li>n ID</li>
</ul>
<p>应用切面</p>
<ul>
<li>关注点分离</li>
<li>beforeMethod</li>
<li>afterMethod</li>
<li>在xml声明AOP属性</li>
</ul>
<p>模板消除样版式代码</p>
<ul>
<li>使用JDBCTemplate封装JDBC的操作</li>
</ul>
<p>Spring容器</p>
<ul>
<li>bean工厂（beanFactory）</li>
<li>应用上下文ApplicationContext(AnnotationApplicationConext, pathContext)</li>
</ul>
<h4 id="Bean生命周期"><a href="#Bean生命周期" class="headerlink" title="Bean生命周期"></a>Bean生命周期</h4><ul>
<li>实例化</li>
<li>值与bean引用注入到bean中</li>
<li>如果实现了BeanNameAware 将Bean传递到SetBeanName()方法中</li>
<li>如果实现了BeanFactoryAwere则将bean工厂传入</li>
<li>如果实现了ApplicationConextAware则将上下文引用传入</li>
<li>如果实现了PostProecess接口则掉调用BeforeInitialization</li>
<li>如果bean实现了InitializaingBean接口，则调用AfterPropertSet()方法</li>
<li>如果AfterInitialization方法</li>
<li>disposable销毁</li>
</ul>
<h4 id="如何装配Bean"><a href="#如何装配Bean" class="headerlink" title="如何装配Bean"></a>如何装配Bean</h4><ul>
<li>xml, </li>
<li>java显式装配，</li>
<li>自动化装配</li>
</ul>
<p>自动化装配<br>组件扫描<br>自动装备 @component注解，告知Spring创建Bean<br>@componentScan<br>@Autowired 可以修饰构造方法，可以修改普通方法，自动装配参数， 接口</p>
<h4 id="Spring设计模式"><a href="#Spring设计模式" class="headerlink" title="Spring设计模式"></a>Spring设计模式</h4><ul>
<li>工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例</li>
<li>单例模式：Bean默认为单例模式</li>
<li>代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术</li>
<li>模板方法：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate</li>
<li>观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现–ApplicationListener。</li>
</ul>
<p>JDK动态代理要求被代理的类必须实现一个接口：InvocationHandler 接口，Proxy newProxyInstance()，java反射<br>CGLIB通过继承的方式动态代理： cglib.jar, asm.jar。通过MethodInterceptor 接口  Enhancer 类，调用父类，继承的方式实例化</p>
<h4 id="Spring作用域"><a href="#Spring作用域" class="headerlink" title="Spring作用域"></a>Spring作用域</h4><ul>
<li>singleton : bean在每个Spring ioc 容器中只有一个实例</li>
<li>prototype：一个bean的定义可以有多个实例</li>
<li>request：每次http请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。</li>
<li>session：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</li>
<li>global-session：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</li>
<li><em>注意：*</em> 缺省的Spring bean 的作用域是Singleton。使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。</li>
</ul>
<h4 id="IOC容器加载过程"><a href="#IOC容器加载过程" class="headerlink" title="IOC容器加载过程"></a>IOC容器加载过程</h4><ol>
<li>刷新预处理</li>
<li>将配置信息解析，注册到BeanFactory</li>
<li>设置bean的类加载器</li>
<li>如果有第三方想再bean加载注册完成后，初始化前做点什么(例如修改属性的值，修改bean的scope为单例或者多例。)，提供了相应的模板方法，后面还调用了这个方法的实现，并且把这些个实现类注册到对应的容器中</li>
<li>初始化当前的事件广播器</li>
<li>初始化所有的bean</li>
<li>广播applicationcontext初始化完成。</li>
</ol>
<h4 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h4><p>四个特性</p>
<ul>
<li>Spring Boot starter 依赖整合，合并Maven Gradle构建</li>
<li>自动配置，Spring Boot 4对条件化配置的支持，合理推测所需的bean并自动化配置</li>
<li>命令行接口</li>
<li>Actuator 管理特性</li>
</ul>
<p>Spring Boot为不同的Spring模块提供了许多依赖项。一些最常用的是：<br>spring-boot-starter-data-jpa<br>spring-boot-starter-security<br>spring-boot-starter-test<br>spring-boot-starter-web<br>spring-boot-starter-thymeleaf</p>
]]></content>
      <categories>
        <category>计算机基础知识</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>ConcurrentHashMap</title>
    <url>/2020/05/21/ConcurrentHashMap/</url>
    <content><![CDATA[<h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p>ConcurrentHashMap使用分段锁来实现同步 （ReentrantLock实现CAS来实现的）</p>
<p>默认16线程<br>get使用volatile实现可见性不需要加锁<br>put使用segmentShift / segmentMask来定位segment<br>HashTable 则对这些方法加synchronize来实现锁，效率很低</p>
<h4 id="JDK1-8进行了改进"><a href="#JDK1-8进行了改进" class="headerlink" title="JDK1.8进行了改进"></a>JDK1.8进行了改进</h4><p>使用链表头节点加锁，同一时间只有一个线程可以put，解决并发问题</p>
<ul>
<li>首先new一个新的hash表(nextTable)出来，大小是原来的2倍。后面的rehash都是针对这个新的hash表操作，不涉及原hash表(table)。</li>
<li>然后会对原hash表(table)中的每个链表进行rehash，此时会尝试获取头节点的锁。这一步就保证了在rehash的过程中不能对这个链表执行put操作。</li>
<li>通过sizeCtl控制，使扩容过程中不会new出多个新hash表来。</li>
<li>最后，将所有键值对重新rehash到新表(nextTable)中后，用nextTable将table替换。这就避免了HashMap中get和扩容并发时，可能get到null的问题。</li>
<li>在整个过程中，共享变量的存储和读取全部通过volatile或CAS的方式，保证了线程安全。</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础知识</category>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/2020/05/21/Redis/</url>
    <content><![CDATA[<h4 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h4><ul>
<li>RDB(二进制）</li>
<li>AOF bgrewriteaof</li>
<li>AOF 重写<br>主从复制<br>slaveof</li>
</ul>
<h4 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h4><ul>
<li>字符串String</li>
<li>列表lists</li>
<li>集合 set</li>
<li>有序集合 sorted set </li>
<li>哈希 hash</li>
</ul>
<h4 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h4><ul>
<li>MULTI组装事务</li>
<li>EXEC执行一个事务</li>
<li>DISCARD取消一个事务</li>
<li>WATCH检测key，一旦key执行书屋之前被改变，则取消事务执行</li>
</ul>
<h4 id="Redis与memcache的不同"><a href="#Redis与memcache的不同" class="headerlink" title="Redis与memcache的不同"></a>Redis与memcache的不同</h4><p><strong>value大小不同</strong><br>memcache是一个内存缓存，key的长度小于250字符，单个item存储要小于1M，不适合虚拟机使用</p>
<p><strong>数据一致性不同</strong></p>
<ul>
<li>Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储小数据时比Memcached性能更高。而在100k以上的数据中，Memcached性能要高于Redis，虽然Redis最近也在存储大数据的性能上进行优化，但是比起Memcached，还是稍有逊色。 </li>
<li>redis使用的是单线程模型，保证了数据按顺序提交。</li>
<li>memcache需要使用cas保证数据一致性。CAS 是一个确保并发一致性的机制，属于“乐观锁”范畴；原理很简单：拿版本号，操作，对比版本号，如果一致就操作，不一致就放弃任何操作 </li>
</ul>
<p><strong>cpu利用</strong><br>redis单线程模型只能使用一个cpu，可以开启多个redis进程</p>
]]></content>
      <categories>
        <category>计算机基础知识</category>
      </categories>
  </entry>
  <entry>
    <title>JVM调优</title>
    <url>/2020/05/21/JVM%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[<h4 id="程序检测异常"><a href="#程序检测异常" class="headerlink" title="程序检测异常"></a>程序检测异常</h4><ul>
<li>jvm死机， jvm调优</li>
<li>内存，cpu占用过高， GC调优</li>
<li>检测无法停止</li>
<li>检测无法开始</li>
<li>磁盘空间出现问题 df -hl</li>
</ul>
<h4 id="HotSpot-VM"><a href="#HotSpot-VM" class="headerlink" title="HotSpot VM"></a>HotSpot VM</h4><ul>
<li>栈区异常： stackOverFlow 如果栈可以动态扩展，直到内存不足会OOM —Xss</li>
<li>堆区异常：OOM -Xms（min) -Xmx(max)指定内存，实例对象或者数组超出内存</li>
<li>方法区异常：（存放加载过的类，静态变量，常量）永久代很少出现GC -XX PermSize -XX MaxPermSize</li>
<li>运行时常量池：String.intern()生成常量导致OOM</li>
<li>直接内存：虚拟机外内存，NIO有directByteBuffer操作</li>
</ul>
<p>Dump文件，内存泄漏查看GC root引用路径为什么无法自动回收<br>内存溢出 对象仍然存活，调大内存，或者降低对象生命周期</p>
<p><strong>垃圾收集器</strong><br>CMS, ParNew</p>
<h4 id="如何排查？"><a href="#如何排查？" class="headerlink" title="如何排查？"></a>如何排查？</h4><ul>
<li>TOP命令查看cpu占用率</li>
<li>ps查看进程pid， 线程tid</li>
<li>jstack查看进程信息，可以看到哪一行出现了问题</li>
<li>jmap 导出dump文件</li>
<li>jstat查看分代变化情况</li>
<li>启动时开启gc日志-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps来开启GC日志</li>
</ul>
<p>——OOM unable to create new native thread线程池有问题<br>解决：Xss减少单个thread stack的大小<br>——Exception in thread “main” java.lang.OutOfMemoryError: Java heap space<br>解决：这个意思是堆的内存占用已经达到-Xmx设置的最大值，应该是最常见的OOM错误了。解决思路仍然是先应该在代码中找，怀疑存在内存泄漏，通过jstack和jmap去定位问题。如果说一切都正常，才需要通过调整Xmx的值来扩大内存。<br>——Caused by: java.lang.OutOfMemoryError: Meta space<br>解决：这个意思是元数据区的内存占用已经达到XX:MaxMetaspaceSize设置的最大值，排查思路和上面的一致，参数方面可以通过XX:MaxPermSize来进行调整(这里就不说1.8以前的永久代了)</p>
]]></content>
      <categories>
        <category>计算机基础知识</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java设计模式</title>
    <url>/2020/05/21/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更好的解法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"> 	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">testHolder</span></span>&#123;</span><br><span class="line"> 		<span class="keyword">private</span> <span class="keyword">static</span> Singleton intance = <span class="keyword">new</span> Singleton();</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getIntance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 		<span class="keyword">return</span> testHolder.intance;</span><br><span class="line"> 	&#125; 	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="i-线程同步"><a href="#i-线程同步" class="headerlink" title="i++线程同步"></a>i++线程同步</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="comment">//    private static AtomicInteger atomicInteger = new AtomicInteger(0);</span></span><br><span class="line"><span class="comment">//    private void increase() &#123;</span></span><br><span class="line"><span class="comment">//        atomicInteger.incrementAndGet();</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果是static 则给类加锁，没有static则给方法加锁。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            increase();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//给类加锁则可以实现2个实例并行安全</span></span><br><span class="line">        <span class="comment">//给方法加锁只能实现单个实例的线程安全</span></span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test());</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test());</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="不变模式"><a href="#不变模式" class="headerlink" title="不变模式"></a>不变模式</h3><p>final 修饰变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String no;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Product</span><span class="params">(String no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h3><ul>
<li>blockQueue（加阻塞锁）</li>
<li>disruptor（环形队列，CAS实现无锁操作）</li>
</ul>
<h3 id="future-模型"><a href="#future-模型" class="headerlink" title="future 模型"></a>future 模型</h3><ul>
<li>异步调用。如果函数执行的慢，让被调用者立即返回，后台慢慢处理。</li>
<li>充分利用等待时间</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础知识</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Tree</title>
    <url>/2020/05/21/Tree/</url>
    <content><![CDATA[<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><ol>
<li>节点是红色或黑色。</li>
<li>根节点是黑色。</li>
<li>每个叶子节点都是黑色的空节点（NIL节点）。</li>
<li>每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</li>
<li>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。<br>插入,变色,左旋转,右旋转</li>
</ol>
<p>应用： TreeSet TreeMap<br>平衡二叉树，B树B+树，B*</p>
<h3 id="B树-B-tree"><a href="#B树-B-tree" class="headerlink" title="B树(B-tree)"></a>B树(B-tree)</h3><p>注意:之前有看到有很多文章把B树和B-tree理解成了两种不同类别的树，其实这两个是同一种树;</p>
<p><strong>概念：</strong><br>B树和平衡二叉树稍有不同的是B树属于多叉树又名平衡多路查找树（查找路径不只两个），数据库索引技术里大量使用者B树和B+树的数据结构，让我们来看看他有什么特点;</p>
<p><strong>规则：</strong></p>
<ol>
<li>排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则；</li>
<li>子节点数：非叶节点的子节点数&gt;1，且&lt;=M ，且M&gt;=2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉）；</li>
<li>关键字数：枝节点的关键字数量大于等于ceil(m/2)-1个且小于等于M-1个（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2);</li>
<li>所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子;<br>最后我们用一个图和一个实际的例子来理解B树（这里为了理解方便我就直接用实际字母的大小来排列C&gt;B&gt;A）</li>
</ol>
<p><strong>优点：</strong><br>B树相对于平衡二叉树的不同是，每个节点包含的关键字增多了，特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围；把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度;</p>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><ol>
<li>B+跟B树不同B+树的非叶子节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个非叶子节点所能保存的关键字大大增加；</li>
<li>B+树叶子节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；</li>
</ol>
]]></content>
      <categories>
        <category>计算机基础知识</category>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>Java反射</title>
    <url>/2020/05/21/Java%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h4 id="反射机制的作用"><a href="#反射机制的作用" class="headerlink" title="反射机制的作用"></a>反射机制的作用</h4><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性，实现了基本的动态性。<br>有了反射，我们可以做以下事情：</p>
<ul>
<li>在运行时检查一个对象</li>
<li>在运行时，根据一个class构造一个对象</li>
<li>在运行时，检查一个对象的属性和方法</li>
<li>在运行时，调用一个对象的任意一个方法</li>
<li>在运行时，改变对象的构造函数，属性，方法的可见性</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础知识</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java多线程</title>
    <url>/2020/05/21/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h4 id="线程与进程区别："><a href="#线程与进程区别：" class="headerlink" title="线程与进程区别："></a>线程与进程区别：</h4><ol>
<li>进程是资源分配的最小单位,线程是CPU调度的最小单位  </li>
<li>一个进程由一个或多个线程组成  </li>
<li>进程之间相互独立，每个进程都有独立的代码和数据空间,但同一进程下的各个线程之间共享进程的代码和内存空间，每个线程有独立的运行栈和程序计数器  </li>
<li>线程上下文切换比进程上下文切换要快得多</li>
</ol>
<h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>线程安全：就是说多线程访问同一代码，不会产生不确定的结果。（vector, hashTable是线程安全的， arrayList和 hashMap是不安全的）</p>
<ol>
<li>synchronized同步方法  即有synchronized关键字修饰的方法。由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。   也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类   </li>
<li>synchronized同步代码块   即有synchronized关键字修饰的语句块。   当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其它线程对该object对象所有同步代码部分的访问都被暂时阻塞，但仍然可以访问该object中的非synchronized(this)同步代码块。 </li>
<li>volatile实现线程同步  用volatile修饰的变量，线程在每次使用变量的时候，都会从主存中读取变量最新值。变量修改后会直接改变主存内容。保证可见性，不能保证原子性 </li>
<li>使用重入锁实现线程同步ReentrantLock  ReentrantLock 拥有Synchronized相同的并发性和内存语义，此外还多了 锁投票，定时锁等候和中断锁等候,比如可以放弃锁等待先做别的事情（trylock），而Synchronized不能  synchronized是在JVM层面上实现的，JVM会自动释放锁定，但是使用Lock则不行，lock是通过代码实现的，要保证锁定一定会被释放，就必须将unLock()放到finally{}中  在资源竞争很激烈的情况下，ReetrantLock的性能要优于Synchronized  </li>
<li>使用ThreadLocal管理变量  使用该变量的线程都获得该变量的副本，副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。</li>
</ol>
]]></content>
      <categories>
        <category>计算机基础知识</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Trapping Rain Water</title>
    <url>/2020/05/21/Trapping-Rain-Water/</url>
    <content><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote><p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p>
<p>The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!</p>
<p>Example:<br>Input: [0,1,0,2,1,0,1,3,2,1,2,1]<br>Output: 6</p>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/trapping-rain-water/" target="_blank" rel="noopener">leetcode.com/problems/trapping-rain-water</a></cite></footer></blockquote>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@param: int[] height, height of bar;</span></span><br><span class="line"><span class="comment">@return: int, maximum rain water;</span></span><br><span class="line"><span class="comment">Algorithm: 保持两个指针从左右两端，逐渐逼近</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (height.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// two pointer, left and right;</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> leftHeight = height[left];</span><br><span class="line">    <span class="keyword">int</span> rightHeight = height[right];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftHeight &lt; rightHeight) &#123;</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span> (leftHeight &lt; height[left]) &#123;</span><br><span class="line">                leftHeight = height[left];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                result += leftHeight - height[left];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            right--;</span><br><span class="line">            <span class="keyword">if</span> (rightHeight &lt; height[right]) &#123;</span><br><span class="line">                rightHeight = height[right];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                result += rightHeight - height[right];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>Weekly Contest 190</title>
    <url>/2020/05/23/Weekly-Contest-190/</url>
    <content><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><ol start="1455">
<li>Check If a Word Occurs As a Prefix of Any Word in a Sentence<blockquote><p>Given a sentence that consists of some words separated by a single space, and a searchWord.You have to check if searchWord is a prefix of any word in sentence.</p>
<p>Return the index of the word in sentence where searchWord is a prefix of this word (1-indexed).</p>
<a id="more"></a>
<p>If searchWord is a prefix of more than one word, return the index of the first word (minimum index). If there is no such word return -1.</p>
<p>A prefix of a string S is any leading contiguous substring of S.</p>
<p>Example 1:<br>Input: sentence = “i love eating burger”, searchWord = “burg”<br>Output: 4<br>Explanation: “burg” is prefix of “burger” which is the 4th word in the sentence.</p>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/" target="_blank" rel="noopener">leetcode.com/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence</a></cite></footer></blockquote>

</li>
</ol>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">isPrefixOfWord</span><span class="params">(String sentence, String searchWord)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sentence.length() &lt; searchWord.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    String[] str = sentence.split(<span class="string">" "</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;            </span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; searchWord.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == str[i].length()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;    </span><br><span class="line">            &#125;<span class="keyword">if</span> (j &lt; str[i].length() &amp;&amp; str[i].charAt(j) != searchWord.charAt(j)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == searchWord.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Question-1"><a href="#Question-1" class="headerlink" title="Question"></a>Question</h3><ol start="1456">
<li>Maximum Number of Vowels in a Substring of Given Length<blockquote><p>Given a string s and an integer k.</p>
<p>Return the maximum number of vowel letters in any substring of s with length k.</p>
<p>Vowel letters in English are (a, e, i, o, u).</p>
<p>Example 1:</p>
<p>Input: s = “abciiidef”, k = 3<br>Output: 3<br>Explanation: The substring “iii” contains 3 vowel letters.</p>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/" target="_blank" rel="noopener">leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length</a></cite></footer></blockquote>

</li>
</ol>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxVowels</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() &lt;= <span class="number">0</span> || k == <span class="number">0</span> || s.length() &lt; k) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; s.length() &amp;&amp; j &lt; s.length(); j++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(j);</span><br><span class="line">        <span class="keyword">if</span> (j &lt; i+k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (valid(c)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;                </span><br><span class="line">            max = Math.max(max, count);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (valid(c)) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (valid(s.charAt(i))) &#123;</span><br><span class="line">            count--;</span><br><span class="line">            </span><br><span class="line">        &#125;       </span><br><span class="line">        i++;</span><br><span class="line">        max = Math.max(max, count);</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">'a'</span> || c == <span class="string">'e'</span> || c == <span class="string">'i'</span> || c == <span class="string">'o'</span> || c == <span class="string">'u'</span> ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Question-2"><a href="#Question-2" class="headerlink" title="Question"></a>Question</h3><ol start="1457">
<li>Pseudo-Palindromic Paths in a Binary Tree<blockquote><p>Given a binary tree where node values are digits from 1 to 9. A path in the binary tree is said to be pseudo-palindromic if at least one permutation of the node values in the path is a palindrome.</p>
<p>Return the number of pseudo-palindromic paths going from the root node to leaf nodes.</p>
<p>Example 1:<br>Input: root = [2,3,1,3,1,null,1]<br>Output: 2 </p>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/" target="_blank" rel="noopener">leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree</a></cite></footer></blockquote>

</li>
</ol>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Algorithm: dfs + backtracking</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pseudoPalindromicPaths</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] num = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    dfs(root, num, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span>[] num, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    num[root.val]++;</span><br><span class="line">    <span class="keyword">if</span> (num[root.val]%<span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            dfs(root.left, num, count);                          </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            dfs(root.right, num, count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    num[root.val]--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Question-3"><a href="#Question-3" class="headerlink" title="Question"></a>Question</h3><ol start="1458">
<li>Max Dot Product of Two Subsequences<blockquote><p>Given two arrays nums1 and nums2.</p>
<p>Return the maximum dot product between non-empty subsequences of nums1 and nums2 with the same length.</p>
<p>A subsequence of a array is a new array which is formed from the original array by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, [2,3,5] is a subsequence of [1,2,3,4,5] while [1,5,3] is not).</p>
<p>Example 1:</p>
<p>Input: nums1 = [2,1,-2,5], nums2 = [3,0,-6]<br>Output: 18<br>Explanation: Take subsequence [2,-2] from nums1 and subsequence [3,-6] from nums2.<br>Their dot product is (2<em>3 + (-2)</em>(-6)) = 18.</p>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/max-dot-product-of-two-subsequences/" target="_blank" rel="noopener">leetcode.com/problems/max-dot-product-of-two-subsequences</a></cite></footer></blockquote>

</li>
</ol>
<h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*        </span></span><br><span class="line"><span class="comment">Algorithm：这题一看应该能反应出是dp，题目类似于1143. Longest Common Subsequence。处理subsequence的解法</span></span><br><span class="line"><span class="comment">状态转移方程 设p = nums1[i] * nums2[j]，p &gt; 0, 则状态转移方程dp[i][j] = Max(dp[i-1][j-1]+p, dp[i-1][j], dp[i][j-1], p);</span></span><br><span class="line"><span class="comment">p &lt; 0 则状态转移方程 dp[i][j] = Max(dp[i-1][j-1], dp[i-1][j], dp[i][j-1], p);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDotProduct</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l1 = nums1.length;</span><br><span class="line">    <span class="keyword">int</span> l2 = nums2.length;</span><br><span class="line">    <span class="keyword">if</span> (nums1.length == <span class="number">0</span> || nums2.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[l1][l2];</span><br><span class="line">    </span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = nums1[<span class="number">0</span>] * nums2[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; l1; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = nums1[i] * nums2[<span class="number">0</span>];</span><br><span class="line">        dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>], p);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; l2; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = nums2[j] * nums1[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][j] = Math.max(dp[<span class="number">0</span>][j-<span class="number">1</span>],p);</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; l1; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; l2; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> p = nums1[i] * nums2[j];</span><br><span class="line">            <span class="keyword">if</span> (p &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[i-<span class="number">1</span>][j-<span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + p;                        </span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = p;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j-<span class="number">1</span>], p);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            dp[i][j] = Math.max(dp[i][j], Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]));</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[l1-<span class="number">1</span>][l2-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Contest</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Subsequence</tag>
        <tag>Product</tag>
      </tags>
  </entry>
  <entry>
    <title>【随笔】1.偏见</title>
    <url>/2020/05/24/%E3%80%90%E9%9A%8F%E7%AC%94%E3%80%911-%E5%81%8F%E8%A7%81/</url>
    <content><![CDATA[<p>最近在休息期间看了《王牌对王牌》，让我彻底改变了对歌手华晨宇（花花）的看法，感觉就是一个聪明、单纯、善良、有才华的大男孩。然后听了他的好几首歌曲，莫名觉得特别好听，突然转粉了。回过头来仔细想想，对偏见与刻板印象有了新的理解，也算是这段时间最大的反思和感悟了。</p>
<p>记得2013年的时候看过几期《快乐男生》，当时不知道为什么对花花印象特别差，认为他是个生活不能自理，台上“发神经”的男孩。其实当时都没有仔细听他唱过几首歌，就是因为镜头上的几个剪辑，对他留下了这种刻板印象，之后就再也没有关注过他。</p>
<p>现在想来感觉自己真是幼稚。评价一个歌手，主要通过他的歌曲，而我甚至都没有听过他几首歌，就仅由于他的一些行为，就给出了负面评价，形成了刻板印象，导致我否定了他的一切。这种行为跟网络喷子相比，除了没有到处写评论当键盘侠，还有何异？</p>
<p>留学期间最大的感受是可以接触到来自全球各地的人，刚开始遇到的时候可能会留有之前存在的某种偏见和刻板印象。可是通过接触下来，不管是同学、邻居还是路上的行人，感觉大家都很不错。生活了一段时间后，我对世界观有了新的理解：不轻易的评价别人，即使之前的某些经历给我留下了某种印记，但是在没有深入了解对方之前，带着偏见待人都是不礼貌、不成熟的。</p>
<p>我又想为什么会存在偏见？这里引用花花说过的话：人们一直以来不断追求新鲜的事物，但是当新鲜的事物来临的时候，一开始却是不愿意接受的。我非常认同，也在反思自己随着年龄的增长是否不愿意接受一些新鲜的事物，心态是否逐渐老化。这种思维模式一旦形成，会阻碍自己接触新鲜事物，甚至去抵触，抨击。</p>
<p>所以时刻提醒自己要以一种开放的心态对待新鲜的人和事，不轻易评价别人和给别人贴标签，保持包容和尊重，做一个有素质的新青年。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>Sqrt(x)</title>
    <url>/2020/05/24/Sqrt-x/</url>
    <content><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote><p>Implement int sqrt(int x).</p>
<p>Compute and return the square root of x, where x is guaranteed to be a non-negative integer.</p>
<p>Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.</p>
<p>Example 1:<br>Input: 4<br>Output: 2</p>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/sqrtx/" target="_blank" rel="noopener">leetcode.com/problems/sqrtx</a></cite></footer></blockquote>


<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">牛顿迭代法：x^2 = a</span></span><br><span class="line"><span class="comment">某一点x0的切线方程为 f(x) - f(x0) = f'(x0) (x-x0);</span></span><br><span class="line"><span class="comment">=&gt; x = (x0 + a/x0) / 2;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x0 = x;</span><br><span class="line">    <span class="keyword">double</span> x1 = (x0 + x/x0) / <span class="number">2.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> accuracy = <span class="number">1e-6</span>;</span><br><span class="line">    <span class="keyword">while</span> (Math.abs(x0-x1) &gt;= accuracy) &#123;</span><br><span class="line">        x0 = x1;</span><br><span class="line">        x1 = (x0 + x/x0) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) x1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>Mathematics</tag>
      </tags>
  </entry>
  <entry>
    <title>负数计数法</title>
    <url>/2020/05/24/%E8%B4%9F%E6%95%B0%E8%AE%A1%E6%95%B0%E6%B3%95/</url>
    <content><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote><p>给定一个长度为n的数组，该数组中的每个元素在1到n范围内，要求在O(n)的时间复杂度，O(1)的空间复杂度下，打印1到n这n个数各出现了多少次。</p>
</blockquote>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] input = &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>&#125;;</span><br><span class="line"> 		</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; input.length) &#123;</span><br><span class="line">    <span class="keyword">int</span> val = input[i];</span><br><span class="line">    <span class="keyword">if</span> (val &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (val != i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (input[val] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            swap(input, val, i);</span><br><span class="line">            input[val] = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            input[val]—;</span><br><span class="line">            <span class="comment">//计数器清0</span></span><br><span class="line">            input[i] = <span class="number">0</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;			</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; input.length; i++) &#123;			</span><br><span class="line">    System.out.print(input[i] * (-<span class="number">1</span>) +<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>杂题</category>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>O(n)</tag>
      </tags>
  </entry>
  <entry>
    <title>About</title>
    <url>/about/index.html</url>
    <content><![CDATA[<p>I’ve always believed in numbers, in the equations and logics that lead to reason.</p>
<p>But what truly is logic? who decides reasons?</p>
<p>It has taken me through the physical, the metaphysical, the delusional and back.</p>
<p>Ultimately, I have made the most important discovery of my career, the most important discovery of my life:</p>
<p>It is only in the mysterious equations of LOVE that any logical reasons can be found.</p>
]]></content>
  </entry>
  <entry>
    <title>Categories</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Tags</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
