<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Majority Element II</title>
    <url>/2020/05/15/Majority-Element-II/</url>
    <content><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote><p>Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.</p>
<p>Note: The algorithm should run in linear time and in O(1) space.</p>
<p>Example:<br>Input: [3,2,3]<br>Output: [3]</p>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/majority-element-ii/" target="_blank" rel="noopener">leetcode.com/problems/majority-element-ii</a></cite></footer></blockquote>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">最多2个出现次数超过n/3的元素</span></span><br><span class="line"><span class="comment">算法：类似于Majority Element I, 用两个count， 如果重复则++， 反之--；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> count1 = <span class="number">0</span>, count2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">0</span>, num2 = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums[i];</span><br><span class="line">        <span class="keyword">if</span> (count1 == <span class="number">0</span> &amp;&amp; num2 != n) &#123;</span><br><span class="line">            num1 = n;</span><br><span class="line">            count1++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (num1 == n) &#123;</span><br><span class="line">            count1++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (count2 == <span class="number">0</span>) &#123;</span><br><span class="line">            num2 = n;</span><br><span class="line">            count2++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (num2 == n) &#123;</span><br><span class="line">            count2++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            count1--;</span><br><span class="line">            count2--;</span><br><span class="line">        &#125;            </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//最后得到num1,num2不一定是正解，再循环验证一遍</span></span><br><span class="line">    count1 = <span class="number">0</span>;</span><br><span class="line">    count2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == num1) &#123;</span><br><span class="line">            count1++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == num2) &#123;</span><br><span class="line">            count2++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count1 &gt; nums.length/<span class="number">3</span>) &#123;</span><br><span class="line">        result.add(num1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count2 &gt; nums.length/<span class="number">3</span> &amp;&amp; num1 != num2) &#123;</span><br><span class="line">        result.add(num2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Majority</tag>
      </tags>
  </entry>
  <entry>
    <title>Majority Element</title>
    <url>/2020/05/15/Majority-Element/</url>
    <content><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote><p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p>
<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>
<p>Example:<br>Input: [3,2,3]<br>Output: 3</p>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/majority-element/" target="_blank" rel="noopener">leetcode.com/problems/majority-element</a></cite></footer></blockquote>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Algorithm: 某一元素次数大于一半，将数组里看成两种元素，一种是res，另一种是非res。</span></span><br><span class="line"><span class="comment">记录一个count和对应的num，如果后面元素相等，则count++,反之--，最后count &gt;= 1则num记为res</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>, curMajority = <span class="number">0</span>;        </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            curMajority = num;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (num == curMajority) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curMajority;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Majority</tag>
      </tags>
  </entry>
  <entry>
    <title>Task Scheduler</title>
    <url>/2020/05/14/Task-Scheduler/</url>
    <content><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote><p>Given a char array representing tasks CPU need to do. It contains capital letters A to Z where different letters represent different tasks. Tasks could be done without original order. Each task could be done in one interval. For each interval, CPU could finish one task or just be idle.</p>
<p>However, there is a non-negative cooling interval n that means between two same tasks, there must be at least n intervals that CPU are doing different tasks or just be idle.</p>
<p>You need to return the least number of intervals the CPU will take to finish all the given tasks.</p>
<p>Example:<br>Input: tasks = [“A”,”A”,”A”,”B”,”B”,”B”], n = 2<br>Output: 8<br>Explanation: A -&gt; B -&gt; idle -&gt; A -&gt; B -&gt; idle -&gt; A -&gt; B.</p>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/task-scheduler/" target="_blank" rel="noopener">leetcode.com/problems/task-scheduler</a></cite></footer></blockquote>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">A math problem, what matter is numbers of letter that counts most;</span></span><br><span class="line"><span class="comment">AAABBB</span></span><br><span class="line"><span class="comment">A~~A~~AB</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="keyword">char</span>[] tasks, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tasks.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> tasks.length;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[] num = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> t : tasks) &#123;</span><br><span class="line">        num[t-<span class="string">'A'</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Arrays.sort(num);</span><br><span class="line">    <span class="comment">// calculater numbers of letter that counts most; in this case, 2;</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">25</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; num[i] == num[<span class="number">25</span>]) &#123;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// compare with tasks.length;</span></span><br><span class="line">    <span class="comment">// num[25]-1 is interval;</span></span><br><span class="line">    <span class="comment">// n+1 means A~~A~~, 出现次数最多的字母A，A最后一组之前的数量，</span></span><br><span class="line">    <span class="comment">//再加上与A相同的字母的数量 25-i</span></span><br><span class="line">    <span class="keyword">return</span> Math.max(tasks.length, (num[<span class="number">25</span>]-<span class="number">1</span>) * (n+<span class="number">1</span>) + <span class="number">25</span>-i);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>Mathematics</tag>
      </tags>
  </entry>
  <entry>
    <title>Two Sum</title>
    <url>/2020/05/14/Two-Sum/</url>
    <content><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>
<p>Example:<br>Given nums = [2, 7, 11, 15], target = 9,<br>Because nums[0] + nums[1] = 2 + 7 = 9,<br>return [0, 1].</p>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">leetcode.com/problems/two-sum</a></cite></footer></blockquote>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">hashmap</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i&lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> n = target-nums[i];</span><br><span class="line">        <span class="keyword">if</span> ( map.containsKey(n) )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;map.get(n),i&#125;;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Sum</tag>
      </tags>
  </entry>
  <entry>
    <title>Check If a Number Is Majority Element in a Sorted Array</title>
    <url>/2020/05/15/Check-If-a-Number-Is-Majority-Element-in-a-Sorted-Array/</url>
    <content><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote><p>Given an array nums sorted in non-decreasing order, and a number target, return True if and only if target is a majority element.</p>
<p>A majority element is an element that appears more than N/2 times in an array of length N.</p>
<p>Example:<br>Input: nums = [2,4,5,5,5,5,5,6,6], target = 5<br>Output: true</p>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/check-if-a-number-is-majority-element-in-a-sorted-array/" target="_blank" rel="noopener">leetcode.com/problems/check-if-a-number-is-majority-element-in-a-sorted-array</a></cite></footer></blockquote>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMajorityElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>] == target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (i == len-<span class="number">1</span> || nums[i+<span class="number">1</span>] != target) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i-index+<span class="number">1</span> &gt; len/<span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Majority</tag>
      </tags>
  </entry>
  <entry>
    <title>3Sum</title>
    <url>/2020/05/14/3Sum/</url>
    <content><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote><p>Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.<br>Note:<br>The solution set must not contain duplicate triplets.<br>Example:<br>Given array nums = [-1, 0, 1, 2, -1, -4],<br>A solution set is:<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/3sum/" target="_blank" rel="noopener">leetcode.com/problems/3sum</a></cite></footer></blockquote>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Algorithm: First, get two sum by 0 - nums[index];</span></span><br><span class="line"><span class="comment">then, similarly solve two sum problem;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (nums.length &lt; <span class="number">3</span>) <span class="keyword">return</span> result;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//[-1, 0, 1, 2, -1, -4]</span></span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> target = <span class="number">0</span> - nums[i];        </span><br><span class="line">        <span class="keyword">int</span> left = i + <span class="number">1</span>, right = nums.length - <span class="number">1</span>;            </span><br><span class="line">        CalculateTwoSum(nums, target, left, right, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CalculateTwoSum</span><span class="params">(<span class="keyword">int</span>[] nums,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> target,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> left, </span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> right, </span></span></span><br><span class="line"><span class="function"><span class="params">                            List&lt;List&lt;Integer&gt;&gt; result)</span> </span>&#123;        </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;            </span><br><span class="line">        <span class="keyword">if</span> (nums[left] + nums[right] == target) &#123;</span><br><span class="line">            List&lt;Integer&gt; candidate = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            candidate.add(-target);</span><br><span class="line">            candidate.add(nums[left]);</span><br><span class="line">            candidate.add(nums[right]);                                        </span><br><span class="line">            result.add(candidate);</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left-<span class="number">1</span>]) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right+<span class="number">1</span>]) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[left] + nums[right] &lt; target) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Sum</tag>
      </tags>
  </entry>
  <entry>
    <title>Median Of Two Sorted Arrays</title>
    <url>/2020/05/14/Median-Of-Two-Sorted-Arrays/</url>
    <content><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote><p>There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
<p>You may assume nums1 and nums2 cannot be both empty.<br>Example 1:<br>nums1 = [1, 3]<br>nums2 = [2]<br>The median is 2.0</p>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">leetcode.com/problems/median-of-two-sorted-arrays</a></cite></footer></blockquote>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@param: int[] nums1, int[] nums2: input two sorted array;</span></span><br><span class="line"><span class="comment">@return: median.</span></span><br><span class="line"><span class="comment">Algorithm: can be expended to find kth smallest element in two sorted array;</span></span><br><span class="line"><span class="comment">in this case, median is k/2;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//corner case</span></span><br><span class="line">    <span class="keyword">if</span> (nums1.length == <span class="number">0</span> &amp;&amp; nums2.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = nums1.length + nums2.length;</span><br><span class="line">    <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (findKthNumber(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, k/<span class="number">2</span>) +</span><br><span class="line">                findKthNumber(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, k/<span class="number">2</span>+<span class="number">1</span>)) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> findKthNumber(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, k/<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//find kth Number not index, index should be k-1;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthNumber</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> startOfA,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int</span>[] B, <span class="keyword">int</span> startOfB,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (startOfA &gt;= A.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> B[startOfB + k-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (startOfB &gt;= B.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> A[startOfA + k-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// should consider last case;</span></span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.min(A[startOfA], B[startOfB]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> halfOfA = (startOfA + k/<span class="number">2</span>-<span class="number">1</span> &gt;= A.length) ? Integer.MAX_VALUE : A[startOfA + k/<span class="number">2</span>-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> halfOfB = (startOfB + k/<span class="number">2</span>-<span class="number">1</span> &gt;= B.length) ? Integer.MAX_VALUE : B[startOfB + k/<span class="number">2</span>-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// be careful here, start should be index + number(not index),</span></span><br><span class="line">    <span class="comment">// next k should be k - k/2 (not k/2);</span></span><br><span class="line">    <span class="keyword">if</span> (halfOfA &lt; halfOfB) &#123;</span><br><span class="line">        <span class="keyword">return</span> findKthNumber(A, startOfA + k/<span class="number">2</span>, B, startOfB, k - k/<span class="number">2</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> findKthNumber(A, startOfA, B, startOfB + k/<span class="number">2</span>, k - k/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Kth</tag>
      </tags>
  </entry>
  <entry>
    <title>Best Time to Buy and Sell Stock</title>
    <url>/2020/05/15/Best-Time-to-Buy-and-Sell-Stock/</url>
    <content><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote><p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.<br>Note that you cannot sell a stock before you buy one.</p>
<p>Example 1:<br>Input: [7,1,5,3,6,4]<br>Output: 5<br>Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.Not 7-1 = 6, as selling price needs to be larger than buying price.</p>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">leetcode.com/problems/best-time-to-buy-and-sell-stock</a></cite></footer></blockquote>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@param: int[] prices</span></span><br><span class="line"><span class="comment">@return: int</span></span><br><span class="line"><span class="comment">Algorithm: 记录最小价值，和之后的最大值，计算最大差值max即可。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( prices.length &lt;= <span class="number">1</span> ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> min = prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> ( prices[i] &lt; min)&#123;</span><br><span class="line">            min = prices[i];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            max = Math.max(max, prices[i] - min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Stock</tag>
      </tags>
  </entry>
  <entry>
    <title>Best Time to Buy and Sell Stock IV</title>
    <url>/2020/05/16/Best-Time-to-Buy-and-Sell-Stock-IV/</url>
    <content><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote><p>Say you have an array for which the i-th element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete at most k transactions.<br>Note:<br>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
<p>Example 1:<br>Input: [2,4,1], k = 2<br>Output: 2<br>Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.</p>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">leetcode.com/problems/best-time-to-buy-and-sell-stock-iv</a></cite></footer></blockquote>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= prices.length / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                profit += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        best[i][j] 表示前i天，至多进行j次交易时的最大获益</span></span><br><span class="line"><span class="comment">        sell[i][j] 表示前i天，至多进行j次交易，并且第i天卖出手中的股票时的最大获益</span></span><br><span class="line"><span class="comment">        状态转移:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        sell[i][j] = max(best[i - 1][j - 1], sell[i - 1][j]) + prices[i] - prices[i - 1]</span></span><br><span class="line"><span class="comment">        best[i][j] = max(best[i - 1][j], sell[i][j])</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="keyword">int</span>[][] sell = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][n + <span class="number">1</span>]; <span class="comment">// sell[i][j] 表示前i天，至多进行j次交易，第i天必须sell的最大获益</span></span><br><span class="line">    <span class="keyword">int</span>[][] best = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][n + <span class="number">1</span>]; <span class="comment">// best[i][j] 表示前i天，至多进行j次交易，第i天可以不sell的最大获益</span></span><br><span class="line"></span><br><span class="line">    sell[<span class="number">0</span>][<span class="number">0</span>] = best[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        sell[<span class="number">0</span>][i] = best[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> gainorlose = prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">        sell[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">            sell[i][j] = Math.max(best[(i - <span class="number">1</span>)][j - <span class="number">1</span>] + gainorlose, sell[(i - <span class="number">1</span>)][j] + gainorlose);</span><br><span class="line">            best[i][j] = Math.max(best[(i - <span class="number">1</span>)][j], sell[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> best[(n - <span class="number">1</span>)][k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Stock</tag>
      </tags>
  </entry>
  <entry>
    <title>Best Time to Buy and Sell Stock III</title>
    <url>/2020/05/16/Best-Time-to-Buy-and-Sell-Stock-III/</url>
    <content><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote><p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete at most two transactions.<br>Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p>
<p>Example 1:<br>Input: [3,3,5,0,0,3,1,4]<br>Output: 6<br>Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3</p>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">leetcode.com/problems/best-time-to-buy-and-sell-stock-iii</a></cite></footer></blockquote>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">brute force的优化</span></span><br><span class="line"><span class="comment">双向dp: 一个从左往右计算max profit, 另一个从右往左计算，最后分割，然后取max</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prices.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = prices.length;</span><br><span class="line">    <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> min = prices[<span class="number">0</span>];</span><br><span class="line">    left[<span class="number">0</span>] = <span class="number">0</span>;        </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;                        </span><br><span class="line">        <span class="keyword">if</span> (prices[i] &gt; prices[i-<span class="number">1</span>]) &#123;</span><br><span class="line">            left[i] = Math.max(prices[i]-min, left[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            left[i] = left[i-<span class="number">1</span>];</span><br><span class="line">            min = Math.min(min, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注意计算从右往左的时候是记录max</span></span><br><span class="line">    <span class="keyword">int</span> max = prices[len-<span class="number">1</span>];</span><br><span class="line">    right[len-<span class="number">1</span>] = <span class="number">0</span>;        </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len-<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;                                    </span><br><span class="line">        <span class="keyword">if</span> (prices[i] &lt; prices[i+<span class="number">1</span>]) &#123;</span><br><span class="line">            right[i] = Math.max(max-prices[i], right[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            right[i] = right[i+<span class="number">1</span>];</span><br><span class="line">            max = Math.max(max, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = Math.max(left[len-<span class="number">1</span>], right[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len-<span class="number">1</span>; i++) &#123;</span><br><span class="line">        res = Math.max(left[i]+right[i+<span class="number">1</span>], res); </span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Stock</tag>
      </tags>
  </entry>
  <entry>
    <title>Best Time to Buy and Sell Stock II</title>
    <url>/2020/05/15/Best-Time-to-Buy-and-Sell-Stock-II/</url>
    <content><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote><p>Say you have an array prices for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).<br>Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p>
<p>Example 1:<br>Input: [7,1,5,3,6,4]<br>Output: 7<br>Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4. Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.</p>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">leetcode.com/problems/best-time-to-buy-and-sell-stock-ii</a></cite></footer></blockquote>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">联想一下直方图，求最大的差距</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>])</span><br><span class="line">            maxprofit += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxprofit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Stock</tag>
      </tags>
  </entry>
  <entry>
    <title>Reveal Cards In Increasing Order</title>
    <url>/2020/05/16/Reveal-Cards-In-Increasing-Order/</url>
    <content><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote><p>In a deck of cards, every card has a unique integer.  You can order the deck in any order you want.</p>
<p>Initially, all the cards start face down (unrevealed) in one deck.</p>
<a id="more"></a>
<p>Now, you do the following steps repeatedly, until all cards are revealed:</p>
<p>Take the top card of the deck, reveal it, and take it out of the deck.<br>If there are still cards in the deck, put the next top card of the deck at the bottom of the deck.<br>If there are still unrevealed cards, go back to step 1.  Otherwise, stop.<br>Return an ordering of the deck that would reveal the cards in increasing order.</p>
<p>The first entry in the answer is considered to be the top of the deck.</p>
<p>Example 1:</p>
<p>Input: [17,13,11,2,3,5,7]<br>Output: [2,13,3,11,5,17,7]<br>Explanation:<br>We get the deck in the order [17,13,11,2,3,5,7] (this order doesn’t matter), and reorder it.<br>After reordering, the deck starts as [2,13,3,11,5,17,7], where 2 is the top of the deck.<br>We reveal 2, and move 13 to the bottom.  The deck is now [3,11,5,17,7,13].<br>We reveal 3, and move 11 to the bottom.  The deck is now [5,17,7,13,11].<br>We reveal 5, and move 17 to the bottom.  The deck is now [7,13,11,17].<br>We reveal 7, and move 13 to the bottom.  The deck is now [11,17,13].<br>We reveal 11, and move 17 to the bottom.  The deck is now [13,17].<br>We reveal 13, and move 17 to the bottom.  The deck is now [17].<br>We reveal 17.<br>Since all the cards revealed are in increasing order, the answer is correct.</p>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/reveal-cards-in-increasing-order/" target="_blank" rel="noopener">leetcode.com/problems/reveal-cards-in-increasing-order</a></cite></footer></blockquote>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@param: int[] deck 初始牌的堆放</span></span><br><span class="line"><span class="comment">@return: int[] 可以按照规则得到increading order牌的顺序</span></span><br><span class="line"><span class="comment">Algorithm: 先排序然后逆思路从大到小放一边</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] deckRevealedIncreasing(<span class="keyword">int</span>[] deck) &#123;</span><br><span class="line">    <span class="keyword">if</span> (deck.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> deck;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Arrays.sort(deck); </span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(deck[deck.length-<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = deck.length-<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        queue.add(queue.poll());</span><br><span class="line">        queue.add(deck[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = deck.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        deck[i--] = queue.poll();    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> deck;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Queue</tag>
        <tag>Deque</tag>
      </tags>
  </entry>
  <entry>
    <title>1-bit and 2-bit Characters</title>
    <url>/2020/05/16/1-bit-and-2-bit-Characters/</url>
    <content><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote><p>We have two special characters. The first character can be represented by one bit 0. The second character can be represented by two bits (10 or 11).</p>
<p>Now given a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero.</p>
<p>Example 1:<br>Input:<br>bits = [1, 0, 0]<br>Output: True<br>Explanation:<br>The only way to decode it is two-bit character and one-bit character. So the last character is one-bit character.</p>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/1-bit-and-2-bit-characters/" target="_blank" rel="noopener">leetcode.com/problems/1-bit-and-2-bit-characters</a></cite></footer></blockquote>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOneBitCharacter</span><span class="params">(<span class="keyword">int</span>[] bits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> check(<span class="number">0</span>,bits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span>[] bits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= bits.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index == bits.length-<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index == bits.length-<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bits[index] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (bits[index] == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> check(index+<span class="number">2</span>,bits);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> check(index+<span class="number">1</span>,bits);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
  </entry>
  <entry>
    <title>Max Area of Island</title>
    <url>/2020/05/16/Max-Area-of-Island/</url>
    <content><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote><p>Given a non-empty 2D array grid of 0’s and 1’s, an island is a group of 1’s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.</p>
<a id="more"></a>
<p>Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)</p>
<p>Example 1:<br>[[0,0,1,0,0,0,0,1,0,0,0,0,0],<br> [0,0,0,0,0,0,0,1,1,1,0,0,0],<br> [0,1,1,0,1,0,0,0,0,0,0,0,0],<br> [0,1,0,0,1,1,0,0,1,0,1,0,0],<br> [0,1,0,0,1,1,0,0,1,1,1,0,0],<br> [0,0,0,0,0,0,0,0,0,0,1,0,0],<br> [0,0,0,0,0,0,0,1,1,1,0,0,0],<br> [0,0,0,0,0,0,0,1,1,0,0,0,0]]<br>Given the above grid, return 6. Note the answer is not 11, because the island must be connected 4-directionally</p>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/max-area-of-island/" target="_blank" rel="noopener">leetcode.com/problems/max-area-of-island</a></cite></footer></blockquote>

<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">dfs</span></span><br><span class="line"><span class="comment">*/</span>    </span><br><span class="line"><span class="keyword">int</span> row;</span><br><span class="line"><span class="keyword">int</span> col;</span><br><span class="line"><span class="keyword">int</span> result;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    row = grid.length;</span><br><span class="line">    col = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[row][col];</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span> &amp;&amp; !visited[i][j]) &#123;</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">                dfs(i, j, grid, visited);</span><br><span class="line">                result = Math.max(result, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[][] grid, <span class="keyword">boolean</span>[][] visited)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= row || j &gt;= col || visited[i][j] || grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">    count++;</span><br><span class="line">    dfs(i+<span class="number">1</span>, j, grid, visited);</span><br><span class="line">    dfs(i-<span class="number">1</span>, j, grid, visited);</span><br><span class="line">    dfs(i, j+<span class="number">1</span>, grid, visited);</span><br><span class="line">    dfs(i, j-<span class="number">1</span>, grid, visited);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">BFS</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    Node(<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">int</span> row;</span><br><span class="line"><span class="keyword">int</span> col;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    row = grid.length;</span><br><span class="line">    col = grid[<span class="number">0</span>].length;</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[row][col];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span> &amp;&amp; !visited[i][j]) &#123;</span><br><span class="line">                queue.add(<span class="keyword">new</span> Node(i,j));</span><br><span class="line">                visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                BFS(queue, visited, grid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Queue&lt;Node&gt; queue, <span class="keyword">boolean</span>[][] visited, <span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dirX = &#123;<span class="number">0</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] dirY = &#123;<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        Node cur = queue.poll();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextX = cur.x+dirX[i];</span><br><span class="line">            <span class="keyword">int</span> nextY = cur.y+dirY[i];</span><br><span class="line">            <span class="keyword">if</span> (isValid(nextX, nextY, grid, visited)) &#123;</span><br><span class="line">                visited[nextX][nextY] = <span class="keyword">true</span>;</span><br><span class="line">                queue.add(<span class="keyword">new</span> Node(nextX, nextY));</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    num = Math.max(num, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span>[][] grid, <span class="keyword">boolean</span>[][] visited)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; x &lt; row &amp;&amp; y &lt; col &amp;&amp; !visited[x][y] &amp;&amp; grid[x][y] == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Matrix</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Summary Ranges</title>
    <url>/2020/05/16/Summary-Ranges/</url>
    <content><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote><p>Given a sorted integer array without duplicates, return the summary of its ranges.</p>
<p>Example 1:<br>Input:  [0,1,2,4,5,7]<br>Output: [“0-&gt;2”,”4-&gt;5”,”7”]<br>Explanation: 0,1,2 form a continuous range; 4,5 form a continuous range.</p>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/summary-ranges/" target="_blank" rel="noopener">leetcode.com/problems/summary-ranges</a></cite></footer></blockquote>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@param: int[] nums</span></span><br><span class="line"><span class="comment">@return: List&lt;String&gt;: ranges</span></span><br><span class="line"><span class="comment">Algorithm: 维护一个start,check if nums[i] = nums[i-1]+1,如果不是更新start,add result；</span></span><br><span class="line"><span class="comment">stringBuilder效率更高</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">summaryRanges</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> start = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == nums[i-<span class="number">1</span>] + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;                </span><br><span class="line">            <span class="keyword">if</span> (nums[i-<span class="number">1</span>] == start) &#123;</span><br><span class="line">                add(start, start, result);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                add(start, nums[i-<span class="number">1</span>], result);</span><br><span class="line">            &#125;                                </span><br><span class="line">            start = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[nums.length-<span class="number">1</span>] == start) &#123;</span><br><span class="line">        add(start, start, result);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        add(start, nums[nums.length-<span class="number">1</span>], result);</span><br><span class="line">    &#125;      </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, List&lt;String&gt; result)</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">if</span> (end == start) &#123;</span><br><span class="line">        sb.append(start);</span><br><span class="line">        result.add(sb.toString());</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        sb.append(start);</span><br><span class="line">        sb.append(<span class="string">"-&gt;"</span>);</span><br><span class="line">        sb.append(end);</span><br><span class="line">        result.add(sb.toString());</span><br><span class="line">    &#125;         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2020/05/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><p>进程：分配资源的基本单位<br>线程：独立运行和独立调度的基本单位</p>
<h4 id="进程与线程的区别："><a href="#进程与线程的区别：" class="headerlink" title="进程与线程的区别："></a>进程与线程的区别：</h4><p>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p>
<ul>
<li>一个程序至少有一个进程,一个进程至少有一个线程.</li>
<li>线程的划分尺度小于进程，使得多线程程序的并发性高。</li>
<li>进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</li>
<li>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li>
<li>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。<br>优缺点</li>
</ul>
<p>线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时，线程适合于在SMP(多核处理机)机器上运行，而进程则可以跨机器迁移。</p>
<h3 id="死锁："><a href="#死锁：" class="headerlink" title="死锁："></a>死锁：</h3><ol>
<li>互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。 </li>
<li>请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</li>
<li>不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li>
<li>环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</li>
</ol>
<h4 id="银行家算法："><a href="#银行家算法：" class="headerlink" title="银行家算法："></a>银行家算法：</h4><p>信号量<br>初始化，给与它一个非负数的整数值。<br>运行 P（wait()），信号量S的值将被减少。企图进入临界区块的进程，需要先运行 P（wait()）。当信号量S减为负值时，进程会被挡住，不能继续；当信号量S不为负值时，进程可以获准进入临界区块。<br>运行 V（又称signal()），信号量S的值会被增加。结束离开临界区块的进程，将会运行 V（又称signal()）。当信号量S不为负值时，先前被挡住的其他进程，将可获准进入临界区块。</p>
<h3 id="分页和分段的区别"><a href="#分页和分段的区别" class="headerlink" title="分页和分段的区别"></a>分页和分段的区别</h3><ul>
<li>段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的</li>
<li>段的大小不固定，有它所完成的功能决定；页大大小固定，由系统决定<br>段向用户提供二维地址空间；页向用户提供的是一维地址空间</li>
<li>段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制。</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础知识</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>HTTP协议</title>
    <url>/2020/05/16/HTTP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）。<br>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。</p>
<h4 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h4><ul>
<li>GET：请求指定的页面信息，并返回实体主体。</li>
<li>HEAD：类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</li>
<li>POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</li>
<li>PUT ：从客户端向服务器传送的数据取代指定的文档的内容。</li>
<li>DELETE：请求服务器删除指定的页面。</li>
<li>CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</li>
<li>OPTIONS：允许客户端查看服务器的性能。</li>
<li>TRACE：回显服务器收到的请求，主要用于测试或诊断。</li>
</ul>
<h4 id="HTTP工作原理"><a href="#HTTP工作原理" class="headerlink" title="HTTP工作原理"></a>HTTP工作原理</h4><p>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p>
<h4 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h4><p>HTTP与HTTPS有什么区别？<br>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</p>
<p>HTTPS和HTTP的区别主要如下：</p>
<ul>
<li>https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</li>
<li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li>
<li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li>
<li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li>
</ul>
<h3 id="TCP-三次握手与四次挥手"><a href="#TCP-三次握手与四次挥手" class="headerlink" title="TCP 三次握手与四次挥手"></a>TCP 三次握手与四次挥手</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>1.第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。<br>2.第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。<br>3.第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。<br>可能存在问题：SYN攻击</p>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>所谓四次挥手（Four-Way Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发。</p>
<h3 id="TCP中流量控制机制——滑动窗口"><a href="#TCP中流量控制机制——滑动窗口" class="headerlink" title="TCP中流量控制机制——滑动窗口"></a>TCP中流量控制机制——滑动窗口</h3><p>发送窗口的大小取决于接受窗口。<br>可以有效防止主机性能差距较大时造成的拥塞。</p>
<ul>
<li>地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。</li>
<li>域名系统（Domain Name System缩写DNS，Domain Name被译为域名）是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。</li>
</ul>
<h3 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h3><p>HTTP/2 的主要目标是改进传输性能，更有效地利用网络资源，实现低延迟和高吞吐量。从另一方面看，HTTP 的高层协议语义并不会因为这次版本升级而受影响。所有HTTP 首部、值，以及它们的使用场景都不会变。<br>HTTP/2 致力于突破上一代标准众所周知的性能限制，但它也是对之前1.x 标准的扩展，而非替代。之所以要递增一个大版本到2.0，主要是因为它改变了客户端与服务器之间交换数据的方式</p>
<h4 id="多路复用-Multiplexing"><a href="#多路复用-Multiplexing" class="headerlink" title="多路复用 (Multiplexing)"></a>多路复用 (Multiplexing)</h4><p>多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。有了新的分帧机制后，HTTP/2 不再依赖多个TCP 连接去实现多流并行了。每个数据流都拆分成很多互不依赖的帧，而这些帧可以交错（乱序发送），还可以分优先级。最后再在另一端把它们重新组合起来。HTTP 2.0 连接都是持久化的，而且客户端与服务器之间也只需要一个连接（每个域名一个连接）即可</p>
<h3 id="HTTP3"><a href="#HTTP3" class="headerlink" title="HTTP3"></a>HTTP3</h3><p>IETF中的QUIC工作组致力于创建QUIC传输协议。QUIC是通过UDP完成的TCP替换。</p>
<h4 id="Quic"><a href="#Quic" class="headerlink" title="Quic"></a>Quic</h4><p>Quic(QuickUDP Internet Connections)是一种新的传输方式，与TCP相比，它减少了延迟。表面上，Quic非常类似于在UDP上实现的TCP+TLS+HTTP/2。由于TCP是在操作系统内核和中间件固件中实现的，因此对TCP进行重大更改几乎是不可能的。然而，由于Quic是构建在UDP之上的，所以它没有受到这样的限制。<br>Quic在现有TCP+TLS+HTTP 2上的关键特性包括<br>大大缩短连接建立时间<br>改进的拥塞控制<br>无线头阻塞的多路复用<br>前向纠错<br>连接迁移</p>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>SSL, TLS</p>
<ol>
<li>先进行秘钥和加密算法的协商（非密文）</li>
<li>非对称密码RSA进行会话秘钥的加密</li>
<li>使用会话秘钥（对称加密）进行加密</li>
</ol>
]]></content>
      <categories>
        <category>计算机基础知识</category>
        <category>网络知识</category>
      </categories>
  </entry>
  <entry>
    <title>Java线程池</title>
    <url>/2020/05/16/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>管理线程，避免增加创建线程和销毁线程的资源损耗。因为线程其实也是一个对象，创建一个对象，需要经过类加载过程，销毁一个对象，需要走GC垃圾回收流程，都是需要资源开销的。<br>提高响应速度。 如果任务到达了，相对于从线程池拿线程，重新去创建一条线程执行，速度肯定慢很多。<br>重复利用。 线程用完，再放回池子，可以达到重复利用的效果，节省资源。</p>
<h4 id="线程池参数"><a href="#线程池参数" class="headerlink" title="线程池参数"></a>线程池参数</h4><ul>
<li>corePoolSize：指定了线程池中的线程数量。</li>
<li>maximumPoolSize：指定了线程池中的最大线程数量。</li>
<li>keepAliveTime：当线程池线程数量超过corePoolSize时，多余的空闲线程的存活时间，即超过corePoolSize的空闲线程，在多长时间内会被销毁。</li>
<li>unit：keepAliveTime的单位。</li>
<li>workQueue：任务队列，被提交但尚未被执行的任务。</li>
<li>threadFactory：线程工厂，用于创建线程，一般用默认的即可。</li>
<li>handler：拒绝策略。当任务太多来不及处理时，如何拒绝任务。<h4 id="线程池类型"><a href="#线程池类型" class="headerlink" title="线程池类型"></a>线程池类型</h4></li>
<li>newFixedThreadPool (固定数目线程的线程池)</li>
<li>newCachedThreadPool(可缓存线程的线程池)</li>
<li>newSingleThreadExecutor(单线程的线程池)</li>
<li>newScheduledThreadPool(定时及周期执行的线程池)</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础知识</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java虚拟机</title>
    <url>/2020/05/16/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><ul>
<li>程序计数器</li>
<li>虚拟机栈（java方法服务）与本地方法栈（native方法服务）</li>
<li>堆区 存放实例对象  可达性算法</li>
<li>方法区 (已被加载的类信息，常量，静态变量）运行时常量池（方法区一部分）</li>
<li>直接内存（NIO）</li>
</ul>
<h3 id="对象创建："><a href="#对象创建：" class="headerlink" title="对象创建："></a>对象创建：</h3><p>new 对象<br>检测常量池符号引用是否存在<br>检测这个类是否加载，解析初始化</p>
<ul>
<li>堆分配内存（指针碰撞法，空闲列表法) CMS使用 空闲列表</li>
<li>并发 CAS实现原子性,每个线程分配内存， TLAB实现线程同步安全</li>
<li>内存初始化为0；（实例字段不赋初值也可以用）</li>
<li>虚拟机层面完成了对象初始化，之后<init>来执行代码初始化<br>对象头(hashcode, GC分代年龄，锁标志，线程持有锁， 时间戳等）</li>
</ul>
<h3 id="OOM-（out-of-memory）"><a href="#OOM-（out-of-memory）" class="headerlink" title="OOM （out of memory）"></a>OOM （out of memory）</h3><p>堆区（new object)<br>栈区（stackOverflow, 可以多并发一直建Thread导致OOM）<br>方法区与常量池区（一直new String（i++).intern()<br>直接内存溢出：NIO</p>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>程序计数器，虚拟机栈，本地方法栈随线程自动回收</p>
<p>可达性算法的GC root：<br>虚拟机栈引用对象<br>方法区中静态对象<br>方法区常量引用对象<br>JNI引用对象（native方法）</p>
<p>相互引用要看是否挂在root上。如果是独立的循环闭环，则也会被GC。</p>
<p>引用类型：</p>
<ul>
<li>强引用</li>
<li>软引用</li>
<li>弱引用</li>
<li>虚引用</li>
</ul>
<p>// 可达性分析不可达的对象 要先判断是否finalize() （不同于try finally)</p>
<h4 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h4><ol>
<li>标记清除算法（低效率，内存碎片）</li>
<li>复制算法（内存缩小一半）<br>Eden survivor0 -&gt;survivor1 , 回收Eden survivor0 （E:s0:s1  8:1:1）</li>
<li>标记整理</li>
<li>分代回收</li>
</ol>
<h4 id="垃圾级收集器"><a href="#垃圾级收集器" class="headerlink" title="垃圾级收集器"></a>垃圾级收集器</h4><ol>
<li>Serial收集器</li>
<li>ParNew收集器  serial收集器的多线程版本</li>
<li>Paraller Scavenge收集器 复制算法</li>
<li>Serial old  标记整理算法</li>
<li>Parallel Scavenge</li>
<li>CMS 老年代收集器  标记清除算法 造成内存碎片</li>
<li>G1 标记整理算法  降低停顿时间<br>垃圾收集器：<br>{<br> ParNew 复制算法<br> Parallel Scavenge自适应收集器<br> CMS收集器并发收集器 老年代收集器 标记清除算法 内存碎片 内存整理<br> G1收集器 标记整理 Region 并发标记 清除<br>}</li>
</ol>
<h4 id="内存分配与内存回收策略"><a href="#内存分配与内存回收策略" class="headerlink" title="内存分配与内存回收策略"></a>内存分配与内存回收策略</h4><ol>
<li>Eden区中分配</li>
<li>Eden区不够时 Minor GC 或者  Eden : survivor0 : survivor1 = 8:1:1</li>
<li>大对象直接进入老生代 </li>
<li>长期存活的对象将进入老生代（年龄计数器）<br>Full GC：<br>a) 年老代（Tenured）被写满<br>b) 持久代（Perm）被写满<br>c) System.gc()被调用<br>d) 上一次GC之后Heap的各域分配策略动态变化</li>
</ol>
<p>-Xss调整内存大小</p>
<h3 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h3><ul>
<li>新生代GC频繁发生，很明显是由于虚拟机分配给新生代的空间太小而导致的，Eden区加上一个Survivor区还不到35MB。因此很有必要使用Xmn参数调整新生代的大小。</li>
<li>老生代频繁扩容引起时，调大老生代内存，每次Full Gc老年代都会扩容，但是有时是没有必要的，所以-XX设置成固定值</li>
</ul>
<p>SafePoint每次垃圾收集用户线程必须到最近的safepoint挂起然后等待回收，之后线程恢复</p>
<p>虚拟机执行字节码，字节码中包含操作码</p>
<h3 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h3><p>类型的加载，链接（验证、准备、解析），初始化</p>
<p>类加载时机{<br>加载、验证、准备、解析、初始化、使用和卸载<br>}</p>
<p>类加载触发：</p>
<ol>
<li>读取一个New关键字实例化的时候，读取设置静态字段，调用静态方法（final修饰的静态字段，已经在编译期放在了常量池除外）（static修饰的静态方法)</li>
<li>反射调用的时候，如果没有初始化，则初始化</li>
<li>父类没有初始化，则进行初始化</li>
<li>先进行主类main初始化</li>
</ol>
<p>静态变量会导致类的初始化，常量则直接在常量池中，不会导致类的初始化</p>
<p>类加载详细过程（方法区）：</p>
<ol>
<li>通过类名获取二进制流</li>
<li>静态存储结构-》方法区</li>
<li>内存中生成对象，作为方法区的访问入口<br>加载器 启动类加载器，扩展类加载器，应用程序类加载器</li>
</ol>
<p>验证：保证运行安全(NoSuchMethodError)</p>
<p>准备：方法区分配内存给静态变量，（不包括实例化对象）</p>
<p>解析：将常量池中的符合替换用直接引用<br>类和接口解析，字段解析，方法解析</p>
<p>初始化阶段<br>执行类构造器<clinit></p>
<h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>类加载器的双亲委派模型：除了顶层的启动类加载器，其余类都应有自己的父类加载器<br>过程：如果一个类加载器收到了类加载请求，首先委派给父类加载器完成。Object为顶层加载器。这样可以统一Object类避免造成混乱</p>
<p>破坏双亲委派模型：父类需要调用子类的时候<br>例如调用JDBC的JDK driver connector 会使用SPI破坏双亲委派模型，线程上下文加载器</p>
<h3 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="headerlink" title="虚拟机字节码执行引擎"></a>虚拟机字节码执行引擎</h3><p>运行时栈帧</p>
<ul>
<li>局部变量表</li>
<li>操作数栈 </li>
<li>动态连接</li>
<li>方法返回地址</li>
</ul>
<p>局部变量表：存放方法参数，方法内部定义的局部变量</p>
<p>编译</p>
<ul>
<li>解析与填充符号表 -&gt;语法树 tree结构</li>
<li>注解处理器</li>
<li>语义分析与字节码生成 执行<clinit> 与<init>方法</li>
</ul>
<p>语法糖</p>
<ul>
<li>泛型和类型擦除</li>
<li>自动装箱、拆箱和循环遍历</li>
</ul>
<p>运行与测试<br>Javac -processer</p>
<p>编译优化技术</p>
<ul>
<li>公共子表达式消除</li>
<li>数组边界检测消除</li>
<li>方法内联</li>
<li>逃逸分析（如果一个方法没有被其他外部方法调用，则可以分配到栈内存，只供当前线程使用，否则就分配到堆内存，线程共享）</li>
</ul>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>Synchronized 内部使用monitorenter monitorexit 和锁计数器来实现<br>RentrantLock重入锁<br>CAS</p>
<h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><p>自旋锁和自适应锁<br>锁消除（依靠逃逸分析技术，判断如果数据不会被其他线程访问）<br>锁粗化  内部操作锁比较多，就直接给整体加一个锁<br>轻量级锁CAS操作<br>偏向锁</p>
]]></content>
      <categories>
        <category>计算机基础知识</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>HeapSort</title>
    <url>/2020/05/16/HeapSort/</url>
    <content><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote><p>Build a heap using array. Sort an array by the heap</p>
</blockquote>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> arr[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build heap (rearrange array)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        heapify(arr, n, i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// One by one extract an element from heap</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=n-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Move current root to end</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[<span class="number">0</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// call max heapify on the reduced heap</span></span><br><span class="line">        heapify(arr, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> largest = i; <span class="comment">// Initialize largest as root</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">2</span>*i + <span class="number">1</span>; <span class="comment">// left = 2*i + 1</span></span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">2</span>*i + <span class="number">2</span>; <span class="comment">// right = 2*i + 2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// If left child is larger than root</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt; n &amp;&amp; arr[l] &gt; arr[largest])</span><br><span class="line">        largest = l;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If right child is larger than largest so far</span></span><br><span class="line">    <span class="keyword">if</span> (r &lt; n &amp;&amp; arr[r] &gt; arr[largest])</span><br><span class="line">        largest = r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If largest is not root</span></span><br><span class="line">    <span class="keyword">if</span> (largest != i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> swap = arr[i];</span><br><span class="line">        arr[i] = arr[largest];</span><br><span class="line">        arr[largest] = swap;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Recursively heapify the affected sub-tree</span></span><br><span class="line">        heapify(arr, n, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Array</category>
      </categories>
      <tags>
        <tag>Sort</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>Weekly Contest 189</title>
    <url>/2020/05/17/Weekly-Contest-189/</url>
    <content><![CDATA[<p><a href="https://leetcode.com/contest/weekly-contest-189" target="_blank" rel="noopener">https://leetcode.com/contest/weekly-contest-189</a><br><img src="/images/Weekly-Contest-189.png" alt=""></p>
<h3 id="Number-of-Students-Doing-Homework-at-a-Given-Time"><a href="#Number-of-Students-Doing-Homework-at-a-Given-Time" class="headerlink" title="Number of Students Doing Homework at a Given Time"></a>Number of Students Doing Homework at a Given Time</h3><blockquote><p>Given two integer arrays startTime and endTime and given an integer queryTime.</p>
<p>The ith student started doing their homework at the time startTime[i] and finished it at time endTime[i].</p>
<a id="more"></a>
<p>Return the number of students doing their homework at time queryTime. More formally, return the number of students where queryTime lays in the interval [startTime[i], endTime[i]] inclusive.</p>
<p>Example 1:<br>Input: startTime = [1,2,3], endTime = [3,2,7], queryTime = 4<br>Output: 1<br>Explanation: We have 3 students where:<br>The first student started doing homework at time 1 and finished at time 3 and wasn’t doing anything at time 4.<br>The second student started doing homework at time 2 and finished at time 2 and also wasn’t doing anything at time 4.<br>The third student started doing homework at time 3 and finished at time 7 and was the only student doing homework at time 4.</p>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/number-of-students-doing-homework-at-a-given-time/" target="_blank" rel="noopener">leetcode.com/problems/number-of-students-doing-homework-at-a-given-time</a></cite></footer></blockquote>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">busyStudent</span><span class="params">(<span class="keyword">int</span>[] startTime, <span class="keyword">int</span>[] endTime, <span class="keyword">int</span> queryTime)</span> </span>&#123;        </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; startTime.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (startTime[i] &lt;= queryTime &amp;&amp; endTime[i] &gt;= queryTime) &#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Rearrange-Words-in-a-Sentence"><a href="#Rearrange-Words-in-a-Sentence" class="headerlink" title="Rearrange Words in a Sentence"></a>Rearrange Words in a Sentence</h3><blockquote><p>Given a sentence text (A sentence is a string of space-separated words) in the following format:</p>
<p>First letter is in upper case.<br>Each word in text are separated by a single space.<br>Your task is to rearrange the words in text such that all words are rearranged in an increasing order of their lengths. If two words have the same length, arrange them in their original order.</p>
<p>Return the new text following the format shown above.</p>
<p>Example 1:</p>
<p>Input: text = “Leetcode is cool”<br>Output: “Is cool leetcode”<br>Explanation: There are 3 words, “Leetcode” of length 8, “is” of length 2 and “cool” of length 4.<br>Output is ordered by length and the new first word starts with capital letter.</p>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/rearrange-words-in-a-sentence/" target="_blank" rel="noopener">leetcode.com/problems/rearrange-words-in-a-sentence</a></cite></footer></blockquote>

<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">arrangeWords</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (text.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> text;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    text = (<span class="keyword">char</span>)(text.charAt(<span class="number">0</span>) + <span class="number">32</span>) + text.substring(<span class="number">1</span>,text.length());</span><br><span class="line">    String[] str = text.split(<span class="string">" "</span>,<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    Arrays.sort(str, (o1,o2) -&gt;o1.length() - o2.length());</span><br><span class="line">    </span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (String s: str) &#123;</span><br><span class="line">        res.append(s);</span><br><span class="line">        res.append(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    text = res.toString().substring(<span class="number">0</span>,res.length()-<span class="number">1</span>);</span><br><span class="line">    text = (<span class="keyword">char</span>)(text.charAt(<span class="number">0</span>) - <span class="number">32</span>) + text.substring(<span class="number">1</span>,text.length());</span><br><span class="line">    <span class="keyword">return</span> text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="People-Whose-List-of-Favorite-Companies-Is-Not-a-Subset-of-Another-List"><a href="#People-Whose-List-of-Favorite-Companies-Is-Not-a-Subset-of-Another-List" class="headerlink" title="People Whose List of Favorite Companies Is Not a Subset of Another List"></a>People Whose List of Favorite Companies Is Not a Subset of Another List</h3><blockquote><p>Given the array favoriteCompanies where favoriteCompanies[i] is the list of favorites companies for the ith person (indexed from 0).</p>
<p>Return the indices of people whose list of favorite companies is not a subset of any other list of favorites companies. You must return the indices in increasing order.</p>
<p>Example 1:<br>Input:favoriteCompanies = [[“leetcode”,”google”,”facebook”],[“google”,”microsoft”],[“google”,”facebook”],[“google”],[“amazon”]]<br>Output: [0,1,4]<br>Explanation:<br>Person with index=2 has favoriteCompanies[2]=[“google”,”facebook”] which is a subset of favoriteCompanies[0]=[“leetcode”,”google”,”facebook”] corresponding to the person with index 0.<br>Person with index=3 has favoriteCompanies[3]=[“google”] which is a subset of favoriteCompanies[0]=[“leetcode”,”google”,”facebook”] and favoriteCompanies[1]=[“google”,”microsoft”].<br>Other lists of favorite companies are not a subset of another list, therefore, the answer is [0,1,4].</p>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list/" target="_blank" rel="noopener">leetcode.com/problems/people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list</a></cite></footer></blockquote>

<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">brute force: O(n^3)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">peopleIndexes</span><span class="params">(List&lt;List&lt;String&gt;&gt; favoriteCompanies)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (favoriteCompanies.size() == <span class="number">0</span> || favoriteCompanies.get(<span class="number">0</span>).size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> size = favoriteCompanies.size();</span><br><span class="line">    Map&lt;Integer, Set&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; favoriteCompanies.size(); i++) &#123;</span><br><span class="line">        map.put(i, <span class="keyword">new</span> HashSet&lt;String&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        Set&lt;String&gt; set = map.get(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; favoriteCompanies.get(i).size(); j++) &#123;</span><br><span class="line">            set.add(favoriteCompanies.get(i).get(j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">boolean</span> exist = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        exist = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> temp = <span class="keyword">true</span>;</span><br><span class="line">            Set&lt;String&gt; cur = map.get(j);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; favoriteCompanies.get(i).size(); k++) &#123;                    </span><br><span class="line">                <span class="keyword">if</span> (!cur.contains(favoriteCompanies.get(i).get(k))) &#123;</span><br><span class="line">                    temp = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            exist = exist | temp;</span><br><span class="line">            <span class="keyword">if</span> (exist) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!exist) &#123;</span><br><span class="line">            res.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Maximum-Number-of-Darts-Inside-of-a-Circular-Dartboard"><a href="#Maximum-Number-of-Darts-Inside-of-a-Circular-Dartboard" class="headerlink" title="Maximum Number of Darts Inside of a Circular Dartboard"></a>Maximum Number of Darts Inside of a Circular Dartboard</h3><blockquote><p>You have a very large square wall and a circular dartboard placed on the wall. You have been challenged to throw darts into the board blindfolded. Darts thrown at the wall are represented as an array of points on a 2D plane. </p>
<p>Return the maximum number of points that are within or lie on any circular dartboard of radius r.</p>
<p>Example 1:<br>Input: points = [[-2,0],[2,0],[0,2],[0,-2]], r = 2<br>Output: 4<br>Explanation: Circle dartboard with center in (0,0) and radius = 2 contain all points.</p>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/maximum-number-of-darts-inside-of-a-circular-dartboard/" target="_blank" rel="noopener">leetcode.com/problems/maximum-number-of-darts-inside-of-a-circular-dartboard</a></cite></footer></blockquote>

<h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>先考虑了求三个点构成的三角形的外心，以这个点为圆心，遍历其他点，到外心的距离小于半径则记录count。<br>发现只过了40多个case，解法有问题。学习了一下，见以下解法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参考：https://seattler.io/thread-1163.htm?from=groupmessage&amp;isappinstalled=0</span></span><br><span class="line"><span class="comment">@param: int[][] points 点的坐标, r 半径</span></span><br><span class="line"><span class="comment">@return: int 最大覆盖圆的数</span></span><br><span class="line"><span class="comment">算法：假设有一个大圆可以覆盖所有的点，然后将这个大圆压缩，直到有两个点在圆上，然后根据这两个点和给定的半径确定一个圆。遍历其他点，是否在这个圆中。</span></span><br><span class="line"><span class="comment">即枚举所有的两点组合，然后结合半径求出圆心坐标，遍历其他点，与圆心的距离小于r，则count++，求max count；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">    Point() &#123;&#125;</span><br><span class="line">    Point(<span class="keyword">double</span> x, <span class="keyword">double</span> y) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">double</span> precision = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numPoints</span><span class="params">(<span class="keyword">int</span>[][] points, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (points.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (points.length == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (distance(points[<span class="number">0</span>][<span class="number">0</span>], points[<span class="number">0</span>][<span class="number">1</span>], points[<span class="number">1</span>][<span class="number">0</span>], points[<span class="number">1</span>][<span class="number">1</span>]) - r * r &lt; precision) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; points.length; j++) &#123;</span><br><span class="line">            help(<span class="keyword">new</span> Point(points[i][<span class="number">0</span>],points[i][<span class="number">1</span>]), <span class="keyword">new</span> Point(points[j][<span class="number">0</span>], points[j][<span class="number">1</span>]), r, points);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">help</span><span class="params">(Point a, Point b, <span class="keyword">int</span> r, <span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> x1 = a.x;</span><br><span class="line">        <span class="keyword">double</span> y1 = a.y;</span><br><span class="line">        <span class="keyword">double</span> x2 = b.x;</span><br><span class="line">        <span class="keyword">double</span> y2 = b.y;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">double</span> mx = (x1 + x2) / <span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">double</span> my = (y1 + y2) / <span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">double</span> dx = x1 - x2;</span><br><span class="line">        <span class="keyword">double</span> dy = y1 - y2;</span><br><span class="line">        <span class="keyword">double</span> dis = Math.sqrt(dx * dx + dy * dy);</span><br><span class="line">        <span class="keyword">double</span> disR = Math.sqrt(r * r - dis * dis / <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">double</span> dxR = -dy / dis;</span><br><span class="line">        <span class="keyword">double</span> dyR = dx / dis;</span><br><span class="line">        <span class="keyword">double</span> x = mx + (-dy/dis) * disR;</span><br><span class="line">        <span class="keyword">double</span> y = my + (dx/dis) * disR;</span><br><span class="line">        check(<span class="keyword">new</span> Point(x, y), r, points);</span><br><span class="line">        x = mx - dxR * disR;</span><br><span class="line">        y = my - dyR * disR;</span><br><span class="line">        check(<span class="keyword">new</span> Point(x, y), r, points);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(Point pr, <span class="keyword">int</span> r, <span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] p : points) &#123;</span><br><span class="line">        <span class="keyword">double</span> dx = pr.x - p[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">double</span> dy = pr.y - p[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">double</span> d = dx*dx + dy*dy - r*r;</span><br><span class="line">        <span class="keyword">if</span> (d &lt;= precision) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    max = Math.max(max, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">distance</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> d= (x1-x2) * (x1-x2) + (y1-y2) * (y1-y2);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Contest</category>
      </categories>
      <tags>
        <tag>Mathematics</tag>
        <tag>Circle</tag>
      </tags>
  </entry>
  <entry>
    <title>Unique Paths III</title>
    <url>/2020/05/17/Unique-Paths-III/</url>
    <content><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote><p>On a 2-dimensional grid, there are 4 types of squares:</p>
<p>1 represents the starting square.  There is exactly one starting square.<br>2 represents the ending square.  There is exactly one ending square.</p>
<a id="more"></a>
<p>0 represents empty squares we can walk over.<br>-1 represents obstacles that we cannot walk over.<br>Return the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once.</p>
<p>Example 1:</p>
<p>Input: [[1,0,0,0],[0,0,0,0],[0,0,2,-1]]<br>Output: 2<br>Explanation: We have the following two paths: </p>
<ol>
<li>(0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)</li>
<li>(0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)</li>
</ol>
<footer><strong>LeetCode</strong><cite><a href="https://leetcode.com/problems/unique-paths-iii/" target="_blank" rel="noopener">leetcode.com/problems/unique-paths-iii</a></cite></footer></blockquote>

<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@param: int[][] grid</span></span><br><span class="line"><span class="comment">@return: int</span></span><br><span class="line"><span class="comment">Algorithm: 常规DFS+backtracking</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> res, todo = <span class="number">1</span>, sx, sy, ex, ey, row, col;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsIII</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    row = grid.length;</span><br><span class="line">    col = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">if</span> (row == <span class="number">0</span> || col == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                todo++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                sx = i;</span><br><span class="line">                sy = j;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>) &#123;</span><br><span class="line">                ex = i;</span><br><span class="line">                ey = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(sx, sy, grid);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt;= row || y &gt;= col || grid[x][y] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x == ex &amp;&amp; y == ey ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (todo == <span class="number">0</span>)&#123;</span><br><span class="line">            res++;                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    todo--;</span><br><span class="line">    grid[x][y] = -<span class="number">2</span>;</span><br><span class="line">    dfs(x+<span class="number">1</span>,y,grid);</span><br><span class="line">    dfs(x-<span class="number">1</span>,y,grid);</span><br><span class="line">    dfs(x,y+<span class="number">1</span>,grid);</span><br><span class="line">    dfs(x,y-<span class="number">1</span>,grid);</span><br><span class="line">    todo++;</span><br><span class="line">    grid[x][y] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>Matrix</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>About</title>
    <url>/about/index.html</url>
    <content><![CDATA[<p>I’ve always believed in numbers, in the equations and logics that lead to reason.</p>
<p>But what truly is logic? who decides reasons?</p>
<p>It has taken me through the physical, the metaphysical, the delusional and back.</p>
<p>Ultimately, I have made the most important discovery of my career, the most important discovery of my life:</p>
<p>It is only in the mysterious equations of LOVE that any logical reasons can be found.</p>
]]></content>
  </entry>
  <entry>
    <title>Categories</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Tags</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
